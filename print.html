<!DOCTYPE HTML>
<html lang="en" class="rust" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Wasefire</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('rust')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded "><a href="overview/index.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="overview/terminology.html"><strong aria-hidden="true">1.1.</strong> Terminology</a></li><li class="chapter-item expanded "><a href="overview/features.html"><strong aria-hidden="true">1.2.</strong> Features</a></li></ol></li><li class="chapter-item expanded "><a href="quick/index.html"><strong aria-hidden="true">2.</strong> Quick start</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="quick/codespace.html"><strong aria-hidden="true">2.1.</strong> GitHub Codespace tips</a></li></ol></li><li class="chapter-item expanded "><a href="applet/index.html"><strong aria-hidden="true">3.</strong> Applet user guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="applet/create.html"><strong aria-hidden="true">3.1.</strong> Create a new applet</a></li><li class="chapter-item expanded "><a href="applet/run.html"><strong aria-hidden="true">3.2.</strong> Run an applet</a></li><li class="chapter-item expanded "><a href="applet/api.html"><strong aria-hidden="true">3.3.</strong> API</a></li><li class="chapter-item expanded "><a href="applet/prelude/index.html"><strong aria-hidden="true">3.4.</strong> Prelude</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="applet/prelude/led.html"><strong aria-hidden="true">3.4.1.</strong> LEDs</a></li><li class="chapter-item expanded "><a href="applet/prelude/button.html"><strong aria-hidden="true">3.4.2.</strong> Buttons</a></li><li class="chapter-item expanded "><a href="applet/prelude/timer.html"><strong aria-hidden="true">3.4.3.</strong> Timers</a></li><li class="chapter-item expanded "><a href="applet/prelude/usb.html"><strong aria-hidden="true">3.4.4.</strong> USB</a></li><li class="chapter-item expanded "><a href="applet/prelude/uart.html"><strong aria-hidden="true">3.4.5.</strong> UART</a></li><li class="chapter-item expanded "><a href="applet/prelude/rpc.html"><strong aria-hidden="true">3.4.6.</strong> RPC</a></li><li class="chapter-item expanded "><a href="applet/prelude/store.html"><strong aria-hidden="true">3.4.7.</strong> Storage</a></li></ol></li><li class="chapter-item expanded "><a href="applet/exercises/index.html"><strong aria-hidden="true">3.5.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="applet/examples.html"><strong aria-hidden="true">3.6.</strong> Examples</a></li></ol></li><li class="chapter-item expanded "><a href="runner/index.html"><strong aria-hidden="true">4.</strong> Runner user guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="runner/api.html"><strong aria-hidden="true">4.1.</strong> API</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Developer guide</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Design</div></li></ol></li><li class="chapter-item expanded "><a href="faq.html">FAQ</a></li><li class="chapter-item expanded affix "><a href="links.html">Links</a></li><li class="chapter-item expanded affix "><a href="acknowledgments.html">Acknowledgments</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Wasefire</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/google/wasefire/tree/main/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction"><a href="https://google.github.io/wasefire">Introduction</a></a></h1>
<p>This book is a walk through the <em>Wasefire</em> project.</p>
<h2 id="vision"><a class="header" href="#vision">Vision</a></h2>
<blockquote>
<p>Provide a <strong>simple-to-use</strong> and <strong>secure-by-default</strong> ecosystem for firmware development.</p>
</blockquote>
<h3 id="simple-to-use"><a class="header" href="#simple-to-use">Simple-to-use</a></h3>
<p>The ecosystem aspires to be accessible to projects and developers regardless of their familiarity
with developing secure firmware:</p>
<ul>
<li>No embedded expertise required: Regular software engineers can develop firmware.</li>
<li>No security expertise required: The ecosystem provides secure-by-default options.</li>
<li>No enforced programming language: Developers may use the language of their choice<sup class="footnote-reference"><a href="#pl-choice">1</a></sup>.</li>
<li>No enforced development environment or build system: Developers may use their usual setup.</li>
</ul>
<div class="footnote-definition" id="pl-choice"><sup class="footnote-definition-label">1</sup>
<p>As long as it compiles to WebAssembly (or the target architecture for native applets).</p>
</div>
<h3 id="secure-by-default"><a class="header" href="#secure-by-default">Secure-by-default</a></h3>
<p>Security is the responsibility of the ecosystem, not the developer. The following security
mechanisms are (or are planned to be) in place:</p>
<ul>
<li>Sandboxing of the firmware functions (called applets) from each other and from the firmware
runtime (called platform).</li>
<li>Secure implementation within the platform boundaries (e.g. side-channel resistance, fault
injection protection, etc).</li>
<li>Security reviews for the supported boards (e.g. side-channel attacks, fault injection, etc).</li>
<li>User documentation (and warnings) when the security must rely on user behavior, for example when a
configuration is insecure.</li>
</ul>
<p>Even though the default is to be secure, the ecosystem will provide options to opt-out from some of
the security features for performance or footprint reasons. In other words, the developer is able to
make the trade-off between security and performance, defaulting to security without explicit action.</p>
<h3 id="symbiosis"><a class="header" href="#symbiosis">Symbiosis</a></h3>
<p>Being both simple-to-use and secure-by-default actually goes hand in hand. It cannot be expected for
humans to never do mistake, even if they have embedded and security expertise.</p>
<ul>
<li>By being simple to use, developers will prefer using the ecosystem solution rather than
implementing their own, thus using a secure-by-default solution rather than a possibly insecure
implementation.</li>
<li>By not being concerned with security and embedded details, developers can be more productive and
focus on the actual firmware behavior, following the well-lit path for all security and embedded
questions.</li>
</ul>
<h2 id="non-goals"><a class="header" href="#non-goals">Non-goals</a></h2>
<p>The project is not trying to build a self-service applet store. In particular, users are developers.
A self-service applet store may come at a later phase or may be done independently by another
project. The project will provide anything needed for such applet store to be secure and easy to
use.</p>
<h2 id="disclaimer"><a class="header" href="#disclaimer">Disclaimer</a></h2>
<p>The project is still work in progress and many components might change in the future. However, the
project follows the usual <a href="https://doc.rust-lang.org/cargo/reference/semver.html">Rust semantic
versioning</a> to avoid unexpected breakages.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>This chapter gives a high-level overview of the project.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="terminology"><a class="header" href="#terminology">Terminology</a></h1>
<p>The project will refer to the following components:</p>
<ul>
<li>A <a href="overview/terminology.html#device">Device</a> is a final product with possibly multiple functions.</li>
<li>A <a href="overview/terminology.html#user">User</a> is a person, team, or organization owning the Device.</li>
<li>A <a href="overview/terminology.html#board">Board</a> is the hardware of the Device.</li>
<li>An <a href="overview/terminology.html#applet">Applet</a> is part of the software of the Device implementing a function.</li>
<li>The <a href="overview/terminology.html#board-api">Board API</a> is the hardware abstraction layer.</li>
<li>The <a href="overview/terminology.html#applet-api">Applet API</a> is the platform abstraction layer.</li>
<li>A <a href="overview/terminology.html#prelude">Prelude</a> is a library providing language-specific access to the Applet API.</li>
<li>A <a href="overview/terminology.html#runner">Runner</a> is a binary implementing the Board API and calling the Scheduler.</li>
<li>The <a href="overview/terminology.html#scheduler">Scheduler</a> is the software implementing all the platform logic. It sits between
the Board API and the Applet API.</li>
<li>A <a href="overview/terminology.html#platform">Platform</a> is the binary made of a Runner and the Scheduler.</li>
</ul>
<h2 id="device"><a class="header" href="#device">Device</a></h2>
<p>A Device encompasses the following (non-exhaustive list):</p>
<ul>
<li>A hardware on which to run (chip, form factor, external devices, etc).</li>
<li>How this hardware is configured and initially provisioned.</li>
<li>A set of applets defining the firmware, and their configuration.</li>
<li>What is the funtionality expected from the firmware.</li>
<li>Should the Device be certified.</li>
<li>Where will the Device be installed.</li>
<li>Who will/should have access to the Device.</li>
</ul>
<h2 id="user"><a class="header" href="#user">User</a></h2>
<p>Users may delegate part of the Device design to other teams:</p>
<ul>
<li>Developing hardware or selecting an existing hardware.</li>
<li>Developing one or more applets and/or selecting one or more applets.</li>
<li>Design of the functionality.</li>
<li>Lifetime management (provisioning, logging, monitoring, alerting, census,
etc).</li>
</ul>
<p>Users are responsible for all those steps. The project will however support them in those tasks for
both development and security aspects. For example (non-exhaustive list):</p>
<ul>
<li>The platform provides a serial (ideally unique) for the device.</li>
<li>The platform supports secure updates.</li>
<li>The platform provides applet management (with versioning).</li>
<li>The platform supports some existing hardware (may add support for more based
on demand).</li>
</ul>
<h2 id="board"><a class="header" href="#board">Board</a></h2>
<p>The project provides support for some boards through Runners. Additional boards may be supported
depending on User needs.</p>
<p>Boards may be subject to some restrictions:</p>
<ul>
<li>Only ARM Cortex-M and RISC-V architectures are considered for now.</li>
<li>Minimum flash and RAM requirements (to be defined).</li>
</ul>
<h2 id="applet"><a class="header" href="#applet">Applet</a></h2>
<p>The functionality (or business logic) of a Device is implemented as a set of concurrent applets. The
project provides example applets in the different supported languages for the User to use as
starting point. Eventually, an applet is compiled into WebAssembly which is the only language that
the Scheduler supports<sup class="footnote-reference"><a href="#lang-support">1</a></sup>.</p>
<div class="footnote-definition" id="lang-support"><sup class="footnote-definition-label">1</sup>
<p>There is currently support for native applets as a work-around performance issues.
Such applet is compiled to the target architecture and linked with the platform.</p>
</div>
<h2 id="board-api"><a class="header" href="#board-api">Board API</a></h2>
<p>The Board API is the interface between a Board and the Scheduler and is implemented by a Runner. It
is specified by the <code>wasefire-board-api</code> crate and provides cargo features to select the relevant
part of the API. This selection may be motivated by different reasons:</p>
<ul>
<li>The Board doesn't support some features in hardware and a software implementation is not feasible
or desired.</li>
<li>The User knows that some features are not going to be used by any applets that will run on the
Device. And the space saved by not implementing them is needed for the Device to properly
function.</li>
</ul>
<h2 id="applet-api"><a class="header" href="#applet-api">Applet API</a></h2>
<p>The Applet API is the interface between an Applet and the Scheduler. It is specified by the
<code>wasefire-applet-api-desc</code> crate which can generate code for different languages (e.g. the
<code>wasefire-applet-api</code> crate for Rust). It also provides cargo features to select the relevant part
of the API.</p>
<p>The Board API and Applet API relate by the following points:</p>
<ul>
<li>Together, they provide portability of Applets across different Boards.</li>
<li>They are similar interfaces but with major differences.</li>
<li>The Board API is low-level and trusted by the Scheduler, while the Applet API may be filtered by
the Scheduler based on permissions and capabilities.</li>
</ul>
<h2 id="prelude"><a class="header" href="#prelude">Prelude</a></h2>
<p>The Applet API is defined at the WebAssembly level. Applet developers may use it directly, but
depending on the language this usage may not be convenient. For example, in Rust, using the Applet
API requires the <code>unsafe</code> keyword and thus some good understanding of what's going on. For such
languages, a Prelude is provided to give a simpler and more natural interface to the Applet API. For
example, in Rust, the <code>wasefire</code> crate provides a safe API with high-level Rust-specific types like
<code>&amp;[u8]</code> (instead of the <code>u32</code> pointer and <code>u32</code> length that the Applet API expects).</p>
<h2 id="runner"><a class="header" href="#runner">Runner</a></h2>
<p>The project provides Runners for supported Boards. However, Board support doesn't need to be
provided by the project. The User (for example the team developing the Board) may develop its own
Runner for its own Board. Simplifying the development of Runners (by maximizing the code shared with
other Runners) is part of the project vision. The project simplifies development of both Runners and
Applets, not just Applets.</p>
<h2 id="scheduler"><a class="header" href="#scheduler">Scheduler</a></h2>
<p>Together with the Board API and the Applet API, the Scheduler is the core contribution of the
project and where most security properties are implemented. This is completely provided by the
project and Users cannot alter it. However, they can configure it when configuring a Platform.</p>
<h2 id="platform"><a class="header" href="#platform">Platform</a></h2>
<p>This is the firmware that runs on the Device. It doesn't provide any business logic, but provides
core functionalities through the platform protocol (non-exhaustive list):</p>
<ul>
<li>Secure updates.</li>
<li>Applet management.</li>
<li>Debugging facilities.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="features"><a class="header" href="#features">Features</a></h1>
<p>Features are implemented if their checkbox is checked.</p>
<p>If a feature is not implemented, it doesn't mean it will get implemented. It means this is a feature
that could be implemented if there is a user need.</p>
<p>If a feature is not listed, it doesn't mean it won't get implemented. We may just not be aware of
it, and a user need could justify an implementation.</p>
<h2 id="supported-boards"><a class="header" href="#supported-boards">Supported boards</a></h2>
<p>A board is supported if it has a Runner.</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Linux (for testing without hardware)</li>
<li><input disabled="" type="checkbox" checked=""/>
nRF52840</li>
<li><input disabled="" type="checkbox"/>
OpenTitan</li>
</ul>
<h2 id="supported-applet-languages"><a class="header" href="#supported-applet-languages">Supported applet languages</a></h2>
<p>An applet language is supported if it has a Prelude.</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Rust</li>
<li><input disabled="" type="checkbox"/>
C</li>
<li><input disabled="" type="checkbox"/>
AssemblyScript</li>
</ul>
<p>Note that when running multiple applets concurrently on the same platform, those applets don't need
to be written in the same language to inter-operate.</p>
<h2 id="developer-experience"><a class="header" href="#developer-experience">Developer experience</a></h2>
<h3 id="for-applets"><a class="header" href="#for-applets">For applets</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Development doesn't require hardware (using the Linux board).</li>
<li><input disabled="" type="checkbox" checked=""/>
Testing facilities (using <code>abort()</code> and <code>exit()</code>).</li>
<li><input disabled="" type="checkbox"/>
Fuzzing facilities.</li>
<li><input disabled="" type="checkbox"/>
Debugging facilities.</li>
</ul>
<h3 id="for-runners"><a class="header" href="#for-runners">For runners</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Testing facilities (using the set of example applets suffixed with <code>_test</code>).</li>
</ul>
<h2 id="reproducible-builds"><a class="header" href="#reproducible-builds">Reproducible builds</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Hermetic development environment for applets.</li>
<li><input disabled="" type="checkbox"/>
Hermetic development environment for platforms.</li>
</ul>
<h2 id="secure-platform-upgrades"><a class="header" href="#secure-platform-upgrades">Secure platform upgrades</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
The platform can be upgraded.</li>
<li><input disabled="" type="checkbox"/>
The platform can be downgraded to the extent permitted by the User-configured rollback policy.</li>
<li><input disabled="" type="checkbox"/>
Platform upgrades are digitally signed and verified.</li>
</ul>
<h2 id="applet-sandboxing"><a class="header" href="#applet-sandboxing">Applet sandboxing</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Applets can't tamper with the platform.</li>
<li><input disabled="" type="checkbox"/>
Applets can't tamper with other applets (this is only missing preemptive concurrency).</li>
</ul>
<h2 id="applet-capabilities"><a class="header" href="#applet-capabilities">Applet capabilities</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Applets declare their permissions<sup class="footnote-reference"><a href="#applet-perms">1</a></sup>.</li>
<li><input disabled="" type="checkbox"/>
Applets declare their capabilities (more dynamic concept of permission).</li>
<li><input disabled="" type="checkbox"/>
Applets metadata (or manifest) is signed.</li>
</ul>
<div class="footnote-definition" id="applet-perms"><sup class="footnote-definition-label">1</sup>
<p>This is currently done using the set of imported functions in the WebAssembly
module of the applet. This will most probably use the manifest mechanism in the future.</p>
</div>
<h2 id="platform-side-channel-attack-testing-and-resistance"><a class="header" href="#platform-side-channel-attack-testing-and-resistance">Platform side-channel attack testing and resistance</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Crypto hardware accelerators are leveraged when available (board specific).
<ul>
<li><input disabled="" type="checkbox" checked=""/>
AES CCM (Bluetooth spec) on nRF52840</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
Software crypto primitives are provided as fallback.</li>
<li><input disabled="" type="checkbox"/>
Both of those implementations are side-channel attack resilient.</li>
</ul>
<h2 id="applet-portability"><a class="header" href="#applet-portability">Applet portability</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Applets are portable at binary level (comes from WebAssembly and APIs).</li>
</ul>
<h2 id="applet-multiplexing"><a class="header" href="#applet-multiplexing">Applet multiplexing</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Multiple applets may be installed at the same time.</li>
<li><input disabled="" type="checkbox"/>
Multiple applets may run simultaneously.</li>
<li><input disabled="" type="checkbox"/>
Applets can be installed without running.</li>
<li><input disabled="" type="checkbox"/>
Applets define in their metadata their running condition (e.g. at boot, at USB, at idle, etc).</li>
</ul>
<p>For now, at most one applet can be installed. It immediately starts running after it has been
installed and when the platform boots.</p>
<h2 id="applet-management"><a class="header" href="#applet-management">Applet management</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Applets are identified by a stable id, a version, and a digital signature (verified by the
runtime).</li>
<li><input disabled="" type="checkbox" checked=""/>
Applets may be installed if not already present (within the limit of one applet).</li>
<li><input disabled="" type="checkbox"/>
Applets may be uninstalled in which case all owned resources are deleted.</li>
<li><input disabled="" type="checkbox"/>
Applets may be upgraded (preserving resources) but not downgraded (probably modulo rollback
policy).</li>
<li><input disabled="" type="checkbox"/>
Installed applets can be listed.</li>
</ul>
<p>Applets can be uninstalled and upgraded, but the resources are untouched because there is no mapping
of resources to applets yet (there is no stable identifier).</p>
<h2 id="certification"><a class="header" href="#certification">Certification</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
The runtime can run on certified hardware (FIPS-140-3 and CC).</li>
<li><input disabled="" type="checkbox"/>
TBD: The runtime might sustain being part of the security target for certification.</li>
</ul>
<h2 id="low-power"><a class="header" href="#low-power">Low power</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
If the runtime is only waiting on external hardware events, the CPU is suspended.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start"><a class="header" href="#quick-start">Quick start</a></h1>
<p>Please open an <a href="https://github.com/google/wasefire/issues/new">issue</a> if a step doesn't work.</p>
<h2 id="download-the-wasefire-cli"><a class="header" href="#download-the-wasefire-cli">Download the Wasefire CLI</a></h2>
<h3 id="local-machine"><a class="header" href="#local-machine">Local machine</a></h3>
<p>Download the <a href="https://github.com/google/wasefire/releases/latest">latest release</a> of the Wasefire
CLI for your platform. The code sample below assumes that your platform is
<code>x86_64-unknown-linux-gnu</code> and that your <code>PATH</code> contains <code>~/.local/bin</code>. You may need to adapt the
commands for a different platform or environment.</p>
<pre><code class="language-shell">tar xf wasefire-x86_64-unknown-linux-gnu.tar.gz
rm wasefire-x86_64-unknown-linux-gnu.tar.gz
mkdir -p ~/.local/bin
mv wasefire-x86_64-unknown-linux-gnu ~/.local/bin/wasefire
</code></pre>
<p>You can test that the CLI is correctly installed by running <code>wasefire help</code>.</p>
<p>You can also add shell completion with <code>wasefire completion</code>. You need to place the generated script
where you shell will interpret it, which depends on your shell and configuration. If you use bash
and have root access, you can copy it to <code>/etc/bash_completion.d/wasefire</code> or
<code>/usr/share/bash-completion/completions/wasefire</code>.</p>
<h3 id="github-codespace"><a class="header" href="#github-codespace">GitHub Codespace</a></h3>
<ul>
<li>Open <a href="https://codespaces.new/google/wasefire?quickstart=1">https://codespaces.new/google/wasefire?quickstart=1</a></li>
<li>Click the green <code>Create new codespace</code> (or <code>Resume this codespace</code>) button</li>
<li>Wait a couple minutes for the codespace to be created</li>
</ul>
<h2 id="start-a-host-platform"><a class="header" href="#start-a-host-platform">Start a host platform</a></h2>
<p>You can start a host platform for development with the following command (it will run until
interrupted or killed, so you will need a dedicated terminal):</p>
<pre><code class="language-shell">wasefire host --interface=web
</code></pre>
<p>You may omit <code>--interface=web</code> if you don't need to interact with buttons and LEDs.</p>
<p>This will create a <code>wasefire/host</code> directory in the current directory to store the state of the host
platform.</p>
<p>This will also ask for sudo permissions when using the USB platform protocol, which is the default
(except in GitHub Codespace where <code>export WASEFIRE_PROTOCOL=unix</code> is added to the <code>.bashrc</code> file).
If you don't want to use sudo, you can use the <code>unix</code> or <code>tcp</code> platform protocol. You'll have to
pass <code>--protocol=unix</code> or <code>--protocol=tcp</code> to most <code>wasefire</code> commands or set the
<code>WASEFIRE_PROTOCOL</code> environment variable in your shells.</p>
<h2 id="hello-world-in-rust"><a class="header" href="#hello-world-in-rust">Hello world in Rust</a></h2>
<p>You can create a new Rust applet with:</p>
<pre><code class="language-shell">wasefire rust-applet-new hello
cd hello
</code></pre>
<p>This will create a directory called <code>hello</code> with an example "hello world" applet.</p>
<p>You can build this applet (from the <code>hello</code> directory) with:</p>
<pre><code class="language-shell">wasefire rust-applet-build
</code></pre>
<p>You can also run the unit tests with:</p>
<pre><code class="language-shell">wasefire rust-applet-test
</code></pre>
<p>And you can install it (building it if needed) on a connected platform (for example the host
platform started earlier) with:</p>
<pre><code class="language-shell">wasefire rust-applet-install
</code></pre>
<p>Regardless of the programming language, if you already built an applet (by default under
<code>wasefire/applet.wasm</code>), you can install it with:</p>
<pre><code class="language-shell">wasefire applet-install wasefire/applet.wasm
</code></pre>
<p>And you can uninstall an applet (regardless of programming language) with:</p>
<pre><code class="language-shell">wasefire applet-uninstall
</code></pre>
<p>Wasefire supports only one applet at a time for now. Once multiple applets can be installed
simultaneously, the <code>applet-uninstall</code> command will take an applet ID as argument.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="github-codespace-tips"><a class="header" href="#github-codespace-tips">GitHub Codespace tips</a></h1>
<h2 id="editing-an-applet"><a class="header" href="#editing-an-applet">Editing an applet</a></h2>
<p>For rust-analyzer to work properly, you need to open the applet in its own workspace, for example:</p>
<pre><code class="language-shell">code examples/rust/exercises/part-1
</code></pre>
<p>You can then open the <code>src/lib.rs</code> file and benefit from documentation (hovering a name),
auto-completion, diagnostics, and other rust-analyzer features.</p>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<p>If you get an error about <code>lsmod</code> not found, you must run <code>exec bash</code> to make sure the
<code>WASEFIRE_PROTOCOL</code> environment variable is set. The <code>.bashrc</code> file is modified as part of the
Codespace setup and it may happen that the initial terminal was started before the setup finished.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="applet-user-guide"><a class="header" href="#applet-user-guide">Applet user guide</a></h1>
<p>This chapter describes all you need to know to write an applet. Because we currently only support
Rust for writing applets, this guide only describes Rust usage.</p>
<p>You need to have the Wasefire CLI installed according to the <a href="applet/../quick/index.html">quick start</a>
instructions to be able to continue.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-a-new-applet"><a class="header" href="#create-a-new-applet">Create a new applet</a></h1>
<p>You can create a Rust applet called <code>tutorial</code> with the following command:</p>
<pre><code class="language-shell">wasefire rust-applet-new tutorial
</code></pre>
<p>This creates a <code>tutorial</code> directory with an example Rust applet. Let's look at <code>Cargo.toml</code>:</p>
<ul>
<li>The <code>wasefire</code> dependency provides a Rust interface for the applet API.</li>
<li>The <code>wasefire-stub</code> optional dependency provides support for testing.</li>
<li>The <code>test</code> feature enables testing support.</li>
</ul>
<p>And now let's look at <code>src/lib.rs</code>:</p>
<ul>
<li>The <code>#![no_std]</code> attribute is needed for building WASM modules without WASI. As a consequence, you
cannot use <code>std</code>. Instead, you need to use <code>core</code> and <code>alloc</code>.</li>
<li>The <code>wasefire::applet!();</code> macro does a few things:
<ul>
<li>It makes sure the <code>main()</code> function is executed when the applet starts.</li>
<li>It imports the <code>alloc</code> crate.</li>
<li>It imports all the items of the <code>wasefire</code> crate.</li>
</ul>
</li>
<li>In the <code>tests</code> module, the <code>use wasefire_stub as _;</code> makes sure the <code>wasefire-stub</code> crate is
linked since it provides symbol definitions for the applet API.</li>
</ul>
<p>Since most commands assume they are running from the root directory of the Rust applet (unless
<code>--crate-dir</code> is provided), you can change the working directory to the crate:</p>
<pre><code class="language-shell">cd tutorial
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="run-an-applet"><a class="header" href="#run-an-applet">Run an applet</a></h1>
<p>If you don't have a Wasefire platform, you can start a development platform on your machine
according to the <a href="applet/../quick/index.html">quick start</a> instructions.</p>
<p>You can install a Rust applet with the following command:</p>
<pre><code class="language-shell">wasefire rust-applet-install
</code></pre>
<p>This command does two things:</p>
<ul>
<li>It builds the Rust applet, like <code>wasefire rust-applet-build</code> would.</li>
<li>It installs the built applet, like <code>wasefire applet-install wasefire/applet.wasm</code> would.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api"><a class="header" href="#api">API</a></h1>
<p>The applet API is documented <a href="https://docs.rs/wasefire-applet-api">here</a>.</p>
<p>Note that you probably don't want to use the API directly, but instead want to use the prelude of
your programming language. The API is low-level and corresponds to the interface at WebAssembly
level.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prelude-1"><a class="header" href="#prelude-1">Prelude</a></h1>
<p>This chapter illustrates how to use some parts of the prelude.</p>
<p>The prelude documentation is available <a href="https://docs.rs/wasefire">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="leds"><a class="header" href="#leds">LEDs</a></h1>
<p>In this section, we will walk through the <code>blink</code> example in Rust. It will blink in order each LED
of the board every second in an infinite loop (going back to the first LED after the last LED).</p>
<p>The number of LEDs available on the board is advertised by the <code>led::count()</code> function. We want to
make sure there is at least one LED available:</p>
<pre><code class="language-rust no_run noplayground">    // Make sure there is at least one LED.
    let num_leds = led::count();
    assert!(num_leds &gt; 0, "Board has no LEDs.");</code></pre>
<p>We start the infinite loop cycling through all LEDs in order:</p>
<pre><code class="language-rust no_run noplayground">    // Cycle indefinitely through all LEDs in order.
    for led_index in (0 .. num_leds).cycle() {</code></pre>
<p>Within the infinite loop (notice the indentation), we first turn on the current LED using the
<code>led::set()</code> function:</p>
<pre><code class="language-rust no_run noplayground">        // Turn on the current LED.
        led::set(led_index, led::On);</code></pre>
<p>We now wait for half a second because we want to blink each LED for one second which means half a
second on and half a second off:</p>
<pre><code class="language-rust no_run noplayground">        // Wait before turning it off.
        timer::sleep(Duration::from_millis(500));</code></pre>
<p>Finally, we repeat the same process but turning the LED off before looping to the next LED:</p>
<pre><code class="language-rust no_run noplayground">        // Turn it off and wait before turning on the next LED.
        led::set(led_index, led::Off);
        timer::sleep(Duration::from_millis(500));</code></pre>
<p>The final code looks like this:</p>
<pre><pre class="playground"><code class="language-rust no_run">#![no_std]
wasefire::applet!();

use core::time::Duration;

fn main() {
    // Make sure there is at least one LED.
    let num_leds = led::count();
    assert!(num_leds &gt; 0, "Board has no LEDs.");

    // Cycle indefinitely through all LEDs in order.
    for led_index in (0 .. num_leds).cycle() {
        // Turn on the current LED.
        led::set(led_index, led::On);
        // Wait before turning it off.
        timer::sleep(Duration::from_millis(500));

        // Turn it off and wait before turning on the next LED.
        led::set(led_index, led::Off);
        timer::sleep(Duration::from_millis(500));
    }
}</code></pre></pre>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>The <code>host</code> runner currently has 1 LED and, either prints its state to <code>stdout</code> (the default) or
blinks the LED in the Web UI (with <code>--interface=web</code>). Eventually, the number of LEDs will be
configurable.</p>
<p>To build and install the applet on a connected platform:</p>
<pre><code class="language-shell">wasefire rust-applet-install
</code></pre>
<p>The output in a host platform without Web UI (i.e. <code>wasefire host</code>) should look like this:</p>
<pre><code class="language-text">Applet running.
Led is on
Led is off
Led is on
Led is off
Led is on
Led is off
Led is on
Led is off
Led is on
Led is off
Led is on
Led is off
Led is on
Led is off
Led is on
The applet was killed.
</code></pre>
<p>Where the applet was uninstalled (and thus killed) with <code>wasefire applet-uninstall</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="buttons"><a class="header" href="#buttons">Buttons</a></h1>
<p>In this section, we will walk through 2 Rust examples:</p>
<ul>
<li>The <code>button</code> example illustrates stateless usage but lets us introduce how to handle events with
callbacks.</li>
<li>The <code>led</code> example illustrates stateful usage and thus how to access state in callbacks.</li>
</ul>
<h2 id="stateless-usage"><a class="header" href="#stateless-usage">Stateless usage</a></h2>
<p>This example prints to the debug output the new state of a button each time that button changed
state and so for all buttons.</p>
<p>Similarly to LEDs, there is a <code>button::count()</code> function to discover the number of buttons available
on the board:</p>
<pre><code class="language-rust no_run noplayground">    // Make sure there is at least one button.
    let count = button::count();
    assert!(count &gt; 0, "Board has no buttons.");</code></pre>
<p>We want to listen on events for all available buttons, so we loop over all button indices (starting
at 0):</p>
<pre><code class="language-rust no_run noplayground">    // For each button on the board.
    for index in 0 .. count {</code></pre>
<p>For each button, we define a handler that prints the new button state to the debug output. The
handler takes the new button state as argument. Since <code>button::State</code> implements <code>Debug</code>, we simply
use <code>{state:?}</code> to print the new state.</p>
<pre><code class="language-rust no_run noplayground">        // We define a button handler printing the new state.
        let handler = move |state| debug!("Button {index} has been {state:?}.");</code></pre>
<p>We can now start listening for events. This is done by creating a <code>button::Listener</code> which will call
the provided handler each time the button changes state. We specify the button we want to listen to
by its index and the handler as a closure.</p>
<pre><code class="language-rust no_run noplayground">        // We start listening for state changes with the handler.
        let listener = button::Listener::new(index, handler)?;</code></pre>
<p>A listener continues to listen for events until it is dropped. Since we want to indefinitely listen,
we must not drop the listener. A simple way to do that is to leak it. This is equivalent to calling
<code>core::mem::forget()</code>.</p>
<pre><code class="language-rust no_run noplayground">        // We leak the listener to continue listening for events.
        listener.leak();</code></pre>
<p>Finally, we just endlessly wait for callbacks. This step is optional: waiting for callbacks
indefinitely is the implicit behavior when <code>main</code> exits. In some way, <code>main</code> can be seen as a
callback setup procedure. The <code>scheduling::wait_for_callback()</code> function puts the applet to sleep
until a callback is scheduled and <code>scheduled::wait_indefinitely()</code> is just an infinite loop around
<code>wait_for_callback()</code>.</p>
<pre><code class="language-rust no_run noplayground">    // We indefinitely wait for callbacks.
    scheduling::wait_indefinitely();</code></pre>
<p>The final code looks like this:</p>
<pre><pre class="playground"><code class="language-rust no_run">#![no_std]
wasefire::applet!();

fn main() -&gt; Result&lt;(), Error&gt; {
    // Make sure there is at least one button.
    let count = button::count();
    assert!(count &gt; 0, "Board has no buttons.");

    // For each button on the board.
    for index in 0 .. count {
        // We define a button handler printing the new state.
        let handler = move |state| debug!("Button {index} has been {state:?}.");

        // We start listening for state changes with the handler.
        let listener = button::Listener::new(index, handler)?;

        // We leak the listener to continue listening for events.
        listener.leak();
    }

    // We indefinitely wait for callbacks.
    scheduling::wait_indefinitely();
}</code></pre></pre>
<h2 id="testing-1"><a class="header" href="#testing-1">Testing</a></h2>
<p>The <code>host</code> runner currently has 1 button and is either controlled by typing <code>button</code> on a line on
<code>stdin</code> (the default) or by clicking the button in the Web UI (with <code>--interface=web</code>). With
<code>--interface=stdin</code> (the default), one can also type <code>press</code> and <code>release</code> to control those events
independently. Eventually, the number of buttons will be configurable.</p>
<p>The input and output of a host platform with <code>--interface=stdio</code> could look like this (using <code>&lt;-</code>
for input and <code>-&gt;</code> for output):</p>
<pre><code class="language-text">-&gt; Applet running.
&lt;- button
-&gt; 0.580263: Button 0 has been Pressed.
-&gt; 0.580633: Button 0 has been Released.
&lt;- button
-&gt; 3.308765: Button 0 has been Pressed.
-&gt; 3.309006: Button 0 has been Released.
&lt;- press
-&gt; 4.380741: Button 0 has been Pressed.
&lt;- release
-&gt; 5.436308: Button 0 has been Released.
</code></pre>
<h2 id="stateful-usage"><a class="header" href="#stateful-usage">Stateful usage</a></h2>
<p>This example combines all the LEDs and buttons available on the board by maintaining a dynamic
mapping between them. Initially, all buttons map to the first LED. Each time a button is pressed or
released, the LED it is mapped to is toggled. And when a button is released, it maps to the next LED
(or the first one if it was mapping to the last one).</p>
<p>In particular:</p>
<ul>
<li>A single button can toggle all LEDs.</li>
<li>Multiple buttons can toggle the same LED.</li>
<li>A button may stay pressed while another button is pressed.</li>
<li>All buttons eventually toggle all LEDs.</li>
</ul>
<p>We skip over the setup which doesn't illustrate anything new:</p>
<pre><code class="language-rust no_run noplayground">    // Make sure there is at least one button.
    let num_buttons = button::count();
    assert!(num_buttons &gt; 0, "Board has no buttons.");

    // Make sure there is at least one LED.
    let num_leds = led::count();
    assert!(num_leds &gt; 0, "Board has no LEDs.");

    // For each button on the board.
    for button_index in 0 .. num_buttons {</code></pre>
<p>Because buttons dynamically map to LEDs, we need some state to store this information. For each
button, we'll store the index of the LED to which it maps to in its handler. We have to use interior
mutability (in this case <code>Cell</code>) because the handler is called as <code>&amp;self</code> not <code>&amp;mut self</code><sup class="footnote-reference"><a href="#cell">1</a></sup>.</p>
<pre><code class="language-rust no_run noplayground">        // We create the state containing the LED to which this button maps to.
        let led_state = Cell::new(0);</code></pre>
<p>When defining the button handler, we must move (and thus transfer ownership of) the state we just
created to the handler, such that the handler can read and write the state when called.</p>
<pre><code class="language-rust no_run noplayground">        // We define the button handler and move the state to there.
        let handler = move |button_state| {</code></pre>
<p>When the handler is called, we first toggle the associated LED:</p>
<pre><code class="language-rust no_run noplayground">            // We toggle the LED.
            let led_index = led_state.get();
            led::set(led_index, !led::get(led_index));</code></pre>
<p>And then if the button is released, we update the dynamic mapping to point to the next LED (wrapping
if needed):</p>
<pre><code class="language-rust no_run noplayground">            // If the button is released, we point it to the next LED.
            if matches!(button_state, button::Released) {
                led_state.set((led_index + 1) % num_leds);
            }</code></pre>
<p>Finally, we create a button listener with the defined handler. And we leak it to continue listening
after it goes out of scope and in particular after <code>main</code> returns.</p>
<pre><code class="language-rust no_run noplayground">        // We indefinitely listen by creating and leaking a listener.
        button::Listener::new(button_index, handler)?.leak();</code></pre>
<p>The final code looks like this:</p>
<pre><pre class="playground"><code class="language-rust no_run">#![no_std]
wasefire::applet!();

use core::cell::Cell;

fn main() -&gt; Result&lt;(), Error&gt; {
    // Make sure there is at least one button.
    let num_buttons = button::count();
    assert!(num_buttons &gt; 0, "Board has no buttons.");

    // Make sure there is at least one LED.
    let num_leds = led::count();
    assert!(num_leds &gt; 0, "Board has no LEDs.");

    // For each button on the board.
    for button_index in 0 .. num_buttons {
        // We create the state containing the LED to which this button maps to.
        let led_state = Cell::new(0);

        // We define the button handler and move the state to there.
        let handler = move |button_state| {
            // We toggle the LED.
            let led_index = led_state.get();
            led::set(led_index, !led::get(led_index));

            // If the button is released, we point it to the next LED.
            if matches!(button_state, button::Released) {
                led_state.set((led_index + 1) % num_leds);
            }
        };

        // We indefinitely listen by creating and leaking a listener.
        button::Listener::new(button_index, handler)?.leak();
    }

    Ok(())
}</code></pre></pre>
<div class="footnote-definition" id="cell"><sup class="footnote-definition-label">1</sup>
<p>This is because the handler could wait for callbacks itself and thus the handler may be
reentered. This would essentially copy a mutable reference which is unsound.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="timers"><a class="header" href="#timers">Timers</a></h1>
<p>In this section, we will walk through the <code>button_abort</code> example in Rust. It uses the first button
and the first LED of the board. On a short press, the LED will start blinking. On a long press, the
LED will stop blinking. While the button is pressed, the LED indicates whether the press is short or
long:</p>
<ul>
<li>The LED is on while the press is short.</li>
<li>The LED turns off once the press is long.</li>
</ul>
<p>This applet will need a shared state to know whether the LED must be blinking or not. We cannot
simply use a boolean because the state will be shared. We cannot use <code>Cell&lt;bool&gt;</code> neither because
the state must be in the heap<sup class="footnote-reference"><a href="#heap">1</a></sup>. So we use <code>Rc&lt;Cell&lt;bool&gt;&gt;</code> which is a common pattern when
using callbacks:</p>
<pre><code class="language-rust no_run noplayground">    // We define a shared state to decide whether we must blink.
    let blinking = Rc::new(Cell::new(false));</code></pre>
<p>We can now allocate a timer for the blinking behavior using <code>timer::Timer::new</code>. This function takes
the handler that will be called each time the timer fires. The handler simply toggles the LED if we
must be blinking. Note how we must move a clone of the state to the callback. This is also a common
pattern when using callbacks:</p>
<pre><code class="language-rust no_run noplayground">    // Allocate a timer for blinking the LED.
    let blink = timer::Timer::new({
        // Move a clone of the state to the callback.
        let blinking = blinking.clone();
        move || {
            // Toggle the LED if blinking.
            if blinking.get() {
                led::set(0, !led::get(0));
            }
        }
    });</code></pre>
<p>The rest of the code is done in an infinite loop:</p>
<pre><code class="language-rust no_run noplayground">    loop {</code></pre>
<p>At each iteration, we start by setting up a <code>button::Listener</code> to record whether the button was
pressed and then released. The logic is similar to the callback setup for the timer. The small
difference is that we won't need to call any function on the listener so we prefix its variable name
<code>_button</code> with an underscore. We cannot simply omit the variable name because we don't want to drop
it until the end of the loop iteration, otherwise we would stop listening to button events.</p>
<pre><code class="language-rust no_run noplayground">        // Setup button listeners.
        let pressed = Rc::new(Cell::new(false));
        let released = Rc::new(Cell::new(false));
        let _button = button::Listener::new(0, {
            let pressed = pressed.clone();
            let released = released.clone();
            move |state| match state {
                button::Pressed =&gt; pressed.set(true),
                button::Released if pressed.get() =&gt; released.set(true),
                button::Released =&gt; (),
            }
        })?;</code></pre>
<p>We then wait until the button is pressed using <code>scheduling::wait_until()</code>. This function takes a
condition as argument and only executes callbacks until the condition is satisfied.</p>
<pre><code class="language-rust no_run noplayground">        // Wait for the button to be pressed.
        scheduling::wait_until(|| pressed.get());</code></pre>
<p>According to the specification of this example applet, when the button is pressed we must turn on
the LED (and stop blinking if we were blinking) to signal a possible short press. Note that
callbacks can only executed when a scheduling function is called, so we are essentially in a
critical section. As such, the order in which we do those 3 lines doesn't matter. However, a
callback might be scheduled before we stop the <code>blink</code> timer. It will execute next time we call a
scheduling function. This is ok because when that will happen, the <code>blinking</code> state will be <code>false</code>
and the <code>blink</code> handler will do nothing.</p>
<pre><code class="language-rust no_run noplayground">        // Turn the LED on.
        blink.stop();
        blinking.set(false);
        led::set(0, led::On);</code></pre>
<p>To detect a long press, we need to start a timer. There is nothing new here except the
<code>Timer::start()</code> function which takes the timer mode (one-shot or periodic) and its duration.</p>
<pre><code class="language-rust no_run noplayground">        // Start the timeout to decide between short and long press.
        let timed_out = Rc::new(Cell::new(false));
        let timer = timer::Timer::new({
            let timed_out = timed_out.clone();
            move || timed_out.set(true)
        });
        timer.start(timer::Oneshot, Duration::from_secs(1));</code></pre>
<p>We now wait for the first event between the button being released and the timeout firing. This is
simply done by using a condition which is a disjunction of the events of interest. This is a common
pattern when implementing behavior with a timeout.</p>
<pre><code class="language-rust no_run noplayground">        // Wait for the button to be released or the timeout to fire.
        scheduling::wait_until(|| released.get() || timed_out.get());</code></pre>
<p>To signal that the timeout was reached or the button was released, we turn off the LED.</p>
<pre><code class="language-rust no_run noplayground">        // Turn the LED off.
        led::set(0, led::Off);</code></pre>
<p>Finally, if the press was short (i.e. the button was released before the timeout), we start
blinking. This demonstrates the use of periodic timers.</p>
<pre><code class="language-rust no_run noplayground">        // Start blinking if short press.
        if !timed_out.get() {
            blinking.set(true);
            blink.start(timer::Periodic, Duration::from_millis(200));
        }</code></pre>
<p>There are a few things to note:</p>
<ul>
<li>The code is implicit in Rust, but the button handler and the timer handler within the loop
iteration are dropped before the next iteration. This means that their callbacks are unregistered.
This could be done explicitly by calling <code>core::mem::drop()</code> on their variable if needed.</li>
<li>It is not needed to start and stop the <code>blink</code> timer within the loop as long as it is started
before entering the loop. This is just an optimization to avoid calling the handler when we know
that the <code>blinking</code> shared state is <code>false</code>, because the handler would do nothing in that case.</li>
</ul>
<p>The final code looks like this:</p>
<pre><pre class="playground"><code class="language-rust no_run">#![no_std]
wasefire::applet!();

use alloc::rc::Rc;
use core::cell::Cell;
use core::time::Duration;

fn main() -&gt; Result&lt;(), Error&gt; {
    assert!(button::count() &gt; 0, "Board has no buttons.");
    assert!(led::count() &gt; 0, "Board has no LEDs.");

    // We define a shared state to decide whether we must blink.
    let blinking = Rc::new(Cell::new(false));

    // Allocate a timer for blinking the LED.
    let blink = timer::Timer::new({
        // Move a clone of the state to the callback.
        let blinking = blinking.clone();
        move || {
            // Toggle the LED if blinking.
            if blinking.get() {
                led::set(0, !led::get(0));
            }
        }
    });

    loop {
        // Setup button listeners.
        let pressed = Rc::new(Cell::new(false));
        let released = Rc::new(Cell::new(false));
        let _button = button::Listener::new(0, {
            let pressed = pressed.clone();
            let released = released.clone();
            move |state| match state {
                button::Pressed =&gt; pressed.set(true),
                button::Released if pressed.get() =&gt; released.set(true),
                button::Released =&gt; (),
            }
        })?;

        // Wait for the button to be pressed.
        scheduling::wait_until(|| pressed.get());

        // Turn the LED on.
        blink.stop();
        blinking.set(false);
        led::set(0, led::On);

        // Start the timeout to decide between short and long press.
        let timed_out = Rc::new(Cell::new(false));
        let timer = timer::Timer::new({
            let timed_out = timed_out.clone();
            move || timed_out.set(true)
        });
        timer.start(timer::Oneshot, Duration::from_secs(1));

        // Wait for the button to be released or the timeout to fire.
        scheduling::wait_until(|| released.get() || timed_out.get());

        // Turn the LED off.
        led::set(0, led::Off);

        // Start blinking if short press.
        if !timed_out.get() {
            blinking.set(true);
            blink.start(timer::Periodic, Duration::from_millis(200));
        }
    }
}</code></pre></pre>
<h2 id="testing-2"><a class="header" href="#testing-2">Testing</a></h2>
<p>This is best tested with the Web UI.</p>
<div class="footnote-definition" id="heap"><sup class="footnote-definition-label">1</sup>
<p>If the state were on the stack and a callback were pointing to that state, it would become
a safety requirement to unregister the callback before popping the state from the stack.
However, it is safe to leak a callback with <code>core::mem::forget()</code> and thus not drop it. So we
enforce callbacks to be <code>'static</code> and thus not depend on references to the stack.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usb"><a class="header" href="#usb">USB</a></h1>
<p>For now only USB serial is supported. Eventually, the idea would be for applets to describe the USB
interfaces they need in some init function. The scheduler would then create the USB device based on
those information. And only then start the applets with capabilities to the interfaces they asked
for.</p>
<p>In this section, we will illustrate USB serial usage by walking through the <code>memory_game</code> example.
The game is essentially an infinite loop of memory questions. The player has 3 seconds to memorize a
random base32 string (the length is the current level in the game and thus represents the
difficulty). The player then has 7 seconds to type it back. On success they go to the next level,
otherwise to the previous level.</p>
<p>The applet has only 2 states across loop iterations:</p>
<ul>
<li>The level of the game (and thus the length of the string to remember) starting at 3.</li>
<li>The next prompt to show to the player while they get ready for the next question.</li>
</ul>
<pre><code class="language-rust no_run noplayground">    let mut level = 3; // length of the string to remember
    let mut prompt = "Press ENTER when you are ready.";</code></pre>
<p>Everything else is in the infinite loop:</p>
<pre><code class="language-rust no_run noplayground">    loop {</code></pre>
<p>First thing we do is print the prompt and wait for the player to press Enter. We use ANSI escape
codes to overwrite whatever was there before. As an invariant throughout the game, we always use a
single line of the terminal. This is particularly important to overwrite the question since the
player has to guess it. We write to the USB serial using <code>serial::write_all()</code>. This function is
generic over objects implementing <code>serial::Serial</code>, in this case <code>usb::serial::UsbSerial</code>.</p>
<pre><code class="language-rust no_run noplayground">        serial::write_all(&amp;UsbSerial, format!("\r\x1b[K{prompt}").as_bytes()).unwrap();</code></pre>
<p>We then wait until the player presses Enter. We can read a single byte from the USB serial using
<code>serial::read_byte()</code>. The terminal sends <code>0x0d</code> when Enter is pressed.</p>
<pre><code class="language-rust no_run noplayground">        // Make sure the player is ready.
        while serial::read_byte(&amp;UsbSerial).unwrap() != 0x0d {}</code></pre>
<p>To generate the next question, we use <code>rng::fill_bytes()</code> which fills a buffer with random bytes. We
provide a buffer with the length of the current level. For the string to be printable we truncate
the entropy of each byte from 8 to 5 bits and convert it to a <code>base32</code> symbol.</p>
<pre><code class="language-rust no_run noplayground">        // Generate a question for this level.
        let mut question = vec![0; level];
        rng::fill_bytes(&amp;mut question).unwrap();
        for byte in &amp;mut question {
            const BASE32: [u8; 32] = *b"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
            *byte = BASE32[(*byte &amp; 0x1f) as usize];
        }
        let mut question = String::from_utf8(question).unwrap();</code></pre>
<p>We can now show the question to the player. We do so using a <code>process</code> helper function that we will
also use for the answer. We instantiate this function such that the player has 3 seconds to memorize
the question and may hit Enter at any time to start answering.</p>
<pre><code class="language-rust no_run noplayground">        // Display the question.
        process(3, "Memorize this", &amp;mut question, |_, x| x == 0x0d);</code></pre>
<p>After 3 seconds have elapsed or if the player hit Enter, we read the answer from the player. We give
them 7 seconds to type the answer. We also convert lower-case letters to upper-case for convenience
(it's easier to read upper-case but easier to type lower-case). We also support backspace which the
terminal sends as <code>0x7f</code>. And same as for the question, we let the player exit early with Enter to
avoid waiting until the timeout.</p>
<pre><code class="language-rust no_run noplayground">        // Read the answer.
        let mut answer = String::new();
        process(7, "Type what you remember", &amp;mut answer, |answer, byte| {
            match byte {
                b'A' ..= b'Z' | b'2' ..= b'7' =&gt; answer.push(byte as char),
                b'a' ..= b'z' =&gt; answer.push(byte.to_ascii_uppercase() as char),
                0x7f =&gt; drop(answer.pop()),
                0x0d =&gt; return true,
                _ =&gt; (),
            }
            false
        });</code></pre>
<p>Once we have the answer, we check if it matches the question. If it does, we promote the player to
the next level. If it doesn't, we demote the player to the previous level. However, if there are no
previous level because the player is at level 1, then we let them retry the level to show our
support. We use ANSI escape codes to highlight the result.</p>
<pre><code class="language-rust no_run noplayground">        // Check the answer.
        if answer == question {
            level += 1;
            prompt = "\x1b[1;32mPromotion!\x1b[m Press ENTER for next level.";
        } else if level &gt; 1 {
            level -= 1;
            prompt = "\x1b[1;31mDemotion...\x1b[m Press ENTER for previous level.";
        } else {
            prompt = "\x1b[1;41mRetry?\x1b[m Press ENTER to retry.";
        }</code></pre>
<p>Now that we're done with the main loop, let's look at the <code>process</code> helper. It takes 4 arguments:</p>
<ul>
<li><code>max_secs: usize</code>: the maximum display time in seconds.</li>
<li><code>prompt: &amp;str</code>: the message shown at the beginning of the line.</li>
<li><code>data: &amp;mut String</code>: the data shown after the prompt, which may be updated (see below).</li>
<li><code>update: impl Fn(&amp;mut String, u8) -&gt; bool</code>: the closure called on each input byte possibly
updating the data and returning whether processing should end immediately without waiting for the
maximum display time.</li>
</ul>
<pre><code class="language-rust no_run noplayground">fn process(
    max_secs: usize, prompt: &amp;str, data: &amp;mut String, update: impl Fn(&amp;mut String, u8) -&gt; bool,
) {</code></pre>
<p>The helper counts the number of elapsed seconds in shared variable <code>secs</code> and updates it using a
periodic timer every second.</p>
<pre><code class="language-rust no_run noplayground">    let secs = Rc::new(Cell::new(0));
    let timer = timer::Timer::new({
        let time = secs.clone();
        move || time.set(time.get() + 1)
    });
    timer.start(timer::Periodic, Duration::from_secs(1));</code></pre>
<p>The helper loops as long as the update function didn't say to stop (tracked by the <code>done</code> variable)
and there is still time available.</p>
<pre><code class="language-rust no_run noplayground">    let mut done = false;
    while !done &amp;&amp; secs.get() &lt; max_secs {</code></pre>
<p>We update the line in the terminal with the prompt, time left, and current data. We use ANSI escape
codes to highlight the data and help readability.</p>
<pre><code class="language-rust no_run noplayground">        let secs = max_secs - secs.get();
        let message = format!("\r\x1b[K{prompt} ({secs} seconds remaining): \x1b[1m{data}\x1b[m");
        serial::write_all(&amp;UsbSerial, message.as_bytes()).unwrap();</code></pre>
<p>To be able to update the time left in the terminal we must read from the USB serial asynchronously
using <code>serial::Reader</code>. We create a reader by providing a mutable buffer to which the reader will
write the received bytes.</p>
<pre><code class="language-rust no_run noplayground">        let mut buffer = [0; 8];
        let reader = serial::Reader::new(&amp;UsbSerial, &amp;mut buffer);</code></pre>
<p>We then sleep until a callback is executed using <code>scheduling::wait_for_callback()</code>. This callback
may either be the timer firing the next second or the reader getting input from the USB serial.</p>
<pre><code class="language-rust no_run noplayground">        scheduling::wait_for_callback();</code></pre>
<p>We call <code>Reader::result()</code> to know how many bytes were read from USB serial and written to the
buffer (or if an error occurred). We then simply iterate over the received bytes and update the data
and early exit status according to the provided closure. Same as with timers, when a reader is
dropped, its callback is canceled.</p>
<pre><code class="language-rust no_run noplayground">        let len = reader.result().unwrap();
        for &amp;byte in &amp;buffer[.. len] {
            done |= update(data, byte);
        }</code></pre>
<p>The final code looks like this:</p>
<pre><pre class="playground"><code class="language-rust no_run">#![no_std]
wasefire::applet!();

use alloc::rc::Rc;
use alloc::string::String;
use alloc::{format, vec};
use core::cell::Cell;
use core::time::Duration;

use wasefire::usb::serial::UsbSerial;

fn main() {
    let mut level = 3; // length of the string to remember
    let mut prompt = "Press ENTER when you are ready.";
    loop {
        serial::write_all(&amp;UsbSerial, format!("\r\x1b[K{prompt}").as_bytes()).unwrap();

        // Make sure the player is ready.
        while serial::read_byte(&amp;UsbSerial).unwrap() != 0x0d {}

        // Generate a question for this level.
        let mut question = vec![0; level];
        rng::fill_bytes(&amp;mut question).unwrap();
        for byte in &amp;mut question {
            const BASE32: [u8; 32] = *b"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
            *byte = BASE32[(*byte &amp; 0x1f) as usize];
        }
        let mut question = String::from_utf8(question).unwrap();

        // Display the question.
        process(3, "Memorize this", &amp;mut question, |_, x| x == 0x0d);

        // Read the answer.
        let mut answer = String::new();
        process(7, "Type what you remember", &amp;mut answer, |answer, byte| {
            match byte {
                b'A' ..= b'Z' | b'2' ..= b'7' =&gt; answer.push(byte as char),
                b'a' ..= b'z' =&gt; answer.push(byte.to_ascii_uppercase() as char),
                0x7f =&gt; drop(answer.pop()),
                0x0d =&gt; return true,
                _ =&gt; (),
            }
            false
        });

        // Check the answer.
        if answer == question {
            level += 1;
            prompt = "\x1b[1;32mPromotion!\x1b[m Press ENTER for next level.";
        } else if level &gt; 1 {
            level -= 1;
            prompt = "\x1b[1;31mDemotion...\x1b[m Press ENTER for previous level.";
        } else {
            prompt = "\x1b[1;41mRetry?\x1b[m Press ENTER to retry.";
        }
    }
}

fn process(
    max_secs: usize, prompt: &amp;str, data: &amp;mut String, update: impl Fn(&amp;mut String, u8) -&gt; bool,
) {
    let secs = Rc::new(Cell::new(0));
    let timer = timer::Timer::new({
        let time = secs.clone();
        move || time.set(time.get() + 1)
    });
    timer.start(timer::Periodic, Duration::from_secs(1));
    let mut done = false;
    while !done &amp;&amp; secs.get() &lt; max_secs {
        let secs = max_secs - secs.get();
        let message = format!("\r\x1b[K{prompt} ({secs} seconds remaining): \x1b[1m{data}\x1b[m");
        serial::write_all(&amp;UsbSerial, message.as_bytes()).unwrap();
        let mut buffer = [0; 8];
        let reader = serial::Reader::new(&amp;UsbSerial, &amp;mut buffer);
        scheduling::wait_for_callback();
        let len = reader.result().unwrap();
        for &amp;byte in &amp;buffer[.. len] {
            done |= update(data, byte);
        }
    }
}</code></pre></pre>
<h2 id="testing-3"><a class="header" href="#testing-3">Testing</a></h2>
<p>The host platform doesn't enable USB serial by default. Pass <code>--usb-serial</code> to enable it:</p>
<pre><code class="language-shell">wasefire host --usb-serial
</code></pre>
<p>Once the applet is running, you can connect to the USB serial with the following command:</p>
<pre><code class="language-shell">picocom -q /dev/ttyACM0
</code></pre>
<p>You can install <code>picocom</code> with <code>sudo apt-get install picocom</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uart"><a class="header" href="#uart">UART</a></h1>
<p>Using the UART is similar to using the USB serial, because the <code>uart::Uart::new(uart_id)</code> object
implements <code>serial::Serial</code>, where <code>uart_id</code> is the UART index. The <code>uart::count()</code> function returns
how many UARTs are available on the device. UART indices must be smaller than this count.</p>
<p>It is usually a good idea to write code that is generic over the serial implementation. This can be
done by using a <code>serial</code> variable implementing <code>serial::Serial</code>. This variable may be instantiated
differently based on a compilation feature:</p>
<pre><code class="language-rust no_run noplayground">#[cfg(feature = "serial_uart")]
let serial = uart::Uart::new(0).unwrap();
#[cfg(feature = "serial_usb")]
let serial = usb::serial::UsbSerial;

serial::write_all(&amp;serial, b"hello").unwrap();</code></pre>
<p>Host platforms don't have a real UART. Instead they create a UNIX socket. You can connect to such a
UART by connecting to the UNIX socket. In a terminal dedicated for the connection (you will need to
close the terminal to close the connection) and from the directory where the host platform is
running, you can run:</p>
<pre><code class="language-shell">socat -,cfmakeraw UNIX-CONNECT:wasefire/host/uart0
</code></pre>
<p>You can install <code>socat</code> with <code>sudo apt-get install socat</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rpc"><a class="header" href="#rpc">RPC</a></h1>
<p>In this section, we will walk through the <code>protocol</code> example in Rust. It converts the case of
alphabetic ASCII characters from its request to its response and switches the letters <code>I</code> and <code>O</code>
(similarly for lower-case the letters <code>i</code> and <code>o</code>).</p>
<p>The platform protocol (used to install applets, update the platform, reboot the platform, etc) also
provides a way to call into an applet by sending a request and reading the response. The applet can
define a handler taking a <code>Vec&lt;u8&gt;</code> request as argument and returning a <code>Vec&lt;u8&gt;</code> response (which
can reuse the backing storage of the request).</p>
<p>In this example, the handler simply converts all characters of the request, prints how many times it
was called, and returns the updated request as its response<sup class="footnote-reference"><a href="#mut">1</a></sup>.</p>
<pre><code class="language-rust no_run noplayground">    let mut counter = 0;
    let handler = move |mut data: Vec&lt;u8&gt;| {
        data.iter_mut().for_each(convert);
        counter += 1;
        debug!("Converted {counter} lines.");
        data
    };</code></pre>
<p>A listener can be created and leaked as usual.</p>
<pre><code class="language-rust no_run noplayground">    rpc::Listener::new(&amp;platform::protocol::RpcProtocol, handler).leak();</code></pre>
<p>The conversion function is straightforward:</p>
<pre><code class="language-rust no_run noplayground">fn convert(x: &amp;mut u8) {
    if x.is_ascii_alphabetic() {
        *x ^= 0x20; // switch case
    }
    if matches!(*x, b'I' | b'O' | b'i' | b'o') {
        *x ^= 0x6; // switch between I and O preserving case
    }
}</code></pre>
<p>The final code looks like this:</p>
<pre><pre class="playground"><code class="language-rust no_run">#![no_std]
wasefire::applet!();

use alloc::vec::Vec;

fn main() {
    let mut counter = 0;
    let handler = move |mut data: Vec&lt;u8&gt;| {
        data.iter_mut().for_each(convert);
        counter += 1;
        debug!("Converted {counter} lines.");
        data
    };
    rpc::Listener::new(&amp;platform::protocol::RpcProtocol, handler).leak();
}

fn convert(x: &amp;mut u8) {
    if x.is_ascii_alphabetic() {
        *x ^= 0x20; // switch case
    }
    if matches!(*x, b'I' | b'O' | b'i' | b'o') {
        *x ^= 0x6; // switch between I and O preserving case
    }
}</code></pre></pre>
<h2 id="testing-4"><a class="header" href="#testing-4">Testing</a></h2>
<p>You can use the <code>wasefire applet-rpc</code> command to send an RPC to an applet. By default it reads from
standard input and write to standard output.</p>
<pre><code class="language-shell">% echo HELLO ping | wasefire applet-rpc
helli PONG
</code></pre>
<div class="footnote-definition" id="mut"><sup class="footnote-definition-label">1</sup>
<p>Note that we don't need interior mutability here, compared to buttons for example. This is
because the RPC handler is not re-entrant. The platform won't send a new request if the previous
request was not responded.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage"><a class="header" href="#storage">Storage</a></h1>
<p>For now only a key-value store is supported for persistent storage. Eventually, additional
facilities may be added: a cyclic logging journal, a file-system, raw flash access, etc.</p>
<p>In this section, we will illustrate the key-value store usage by walking through the <code>store</code> example
which provides direct store access with a text-based interface through the platform protocol applet
RPC mechanism.</p>
<p>The key-value store has 2 restrictions:</p>
<ul>
<li>Keys must be between 0 and 4095</li>
<li>Values must be at most 1023 bytes</li>
</ul>
<p>The second restriction can be worked around by storing large entries as multiple fragments of at
most 1023 bytes each using multiple keys. To support those large entries, we define an abstract
notion of keys. An abstract key is either exactly one key, or a contiguous range of keys.</p>
<pre><code class="language-rust no_run noplayground">enum Key {
    Exact(usize),
    Range(Range&lt;usize&gt;),
}</code></pre>
<p>The store provides 3 operations: <code>insert</code>, <code>find</code>, and <code>remove</code>. Each of those operation comes with
a fragmented variant (working on a range of keys for large values). We define helpers to dispatch to
the regular or fragmented version based on the abstract key.</p>
<pre><code class="language-rust no_run noplayground">fn insert(key: &amp;Key, value: &amp;[u8]) -&gt; Result&lt;(), Error&gt; {
    match key {
        Key::Exact(key) =&gt; store::insert(*key, value),
        Key::Range(keys) =&gt; store::fragment::insert(keys.clone(), value),
    }
}

fn find(key: &amp;Key) -&gt; Result&lt;Option&lt;Box&lt;[u8]&gt;&gt;, Error&gt; {
    match key {
        Key::Exact(key) =&gt; store::find(*key),
        Key::Range(keys) =&gt; store::fragment::find(keys.clone()),
    }
}

fn remove(key: &amp;Key) -&gt; Result&lt;(), Error&gt; {
    match key {
        Key::Exact(key) =&gt; store::remove(*key),
        Key::Range(keys) =&gt; store::fragment::remove(keys.clone()),
    }
}</code></pre>
<p>To ease parsing and processing of RPC requests, we define a straightforward type for commands.</p>
<pre><code class="language-rust no_run noplayground">enum Command&lt;'a&gt; {
    Help,
    Insert { key: Key, value: &amp;'a str },
    Find { key: Key },
    Remove { key: Key },
}</code></pre>
<p>The parsing function is also straightforward.</p>
<pre><code class="language-rust no_run noplayground">impl&lt;'a&gt; Command&lt;'a&gt; {
    fn parse(input: &amp;'a str) -&gt; Result&lt;Self, String&gt; {
        Ok(match *input.split_whitespace().collect::&lt;Vec&lt;_&gt;&gt;().as_slice() {
            [] | ["help"] =&gt; Command::Help,
            ["insert", key, value] =&gt; Command::Insert { key: Key::parse(key)?, value },
            ["find", key] =&gt; Command::Find { key: Key::parse(key)? },
            ["remove", key] =&gt; Command::Remove { key: Key::parse(key)? },
            [command, ..] =&gt; return Err(format!("Invalid command {command:?}")),
        })
    }</code></pre>
<p>The process function is more interesting as we'll describe how the store operations behave. When
processing a command, we may either succeed with an output, or fail with an error. We use strings
because we implement a text-based interface.</p>
<pre><code class="language-rust no_run noplayground">    fn process(&amp;self) -&gt; Result&lt;String, String&gt; {</code></pre>
<p>For the help command, we simply output the grammar for commands.</p>
<pre><code class="language-rust no_run noplayground">        match self {
            Command::Help =&gt; Ok("\
Usage: insert &lt;key&gt;[..&lt;key&gt;] &lt;value&gt;
Usage: find &lt;key&gt;[..&lt;key&gt;]
Usage: remove &lt;key&gt;[..&lt;key&gt;]"
                .to_string()),</code></pre>
<p>For insert commands, we use our helper function for abstract keys and format the output and error
appropriately. When inserting to the store, if the key (or range of keys) is already present, then
its value is overwritten.</p>
<pre><code class="language-rust no_run noplayground">            Command::Insert { key, value } =&gt; match insert(key, value.as_bytes()) {
                Ok(()) =&gt; Ok("Done".to_string()),
                Err(error) =&gt; Err(format!("{error}")),
            },</code></pre>
<p>Remove commands are similar. When removing from the store, it is not an error if the key (or range
of keys) is absent.</p>
<pre><code class="language-rust no_run noplayground">            Command::Remove { key } =&gt; match remove(key) {
                Ok(()) =&gt; Ok("Done".to_string()),
                Err(error) =&gt; Err(format!("{error}")),
            },</code></pre>
<p>Find commands also use the helper function, however they have 2 possible outputs (outside errors):</p>
<ul>
<li>If the key is absent from the store, then <code>None</code> is returned.</li>
<li>If the key is present, then <code>Some</code> is returned with the bytes of the value. Because we implement a
text-based interface, we try to convert the byte slice to a string slice for the output.</li>
</ul>
<pre><code class="language-rust no_run noplayground">            Command::Find { key } =&gt; match find(key) {
                Ok(None) =&gt; Ok("Not found".to_string()),
                Ok(Some(value)) =&gt; match core::str::from_utf8(&amp;value) {
                    Ok(value) =&gt; Ok(format!("Found: {value}")),
                    Err(_) =&gt; Ok(format!("Found (not UTF-8): {value:02x?}")),
                },
                Err(error) =&gt; Err(format!("{error}")),
            },</code></pre>
<p>We can finally write our handler function taking a request as argument and returning a response.</p>
<pre><code class="language-rust no_run noplayground">fn handler(request: Vec&lt;u8&gt;) -&gt; Vec&lt;u8&gt; {
    // Parse and process the request.
    let result: Result&lt;String, String&gt; = try {
        let request = String::from_utf8(request).map_err(|_| "Request is not UTF-8")?;
        Command::parse(&amp;request)?.process()?
    };
    // Format output including error and next prompt.
    let mut output = result.unwrap_or_else(|error| format!("Error: {error}"));
    output.push_str("\n&gt; ");
    output.into_bytes()
}</code></pre>
<p>The main function simply registers an RPC listener with the handler above.</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    rpc::Listener::new(&amp;platform::protocol::RpcProtocol, handler).leak();
}</code></pre>
<p>The final code looks like this:</p>
<pre><pre class="playground"><code class="language-rust no_run">#![no_std]
#![feature(try_blocks)]
wasefire::applet!();

use alloc::boxed::Box;
use alloc::format;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::num::ParseIntError;
use core::ops::Range;
use core::str::FromStr;

fn main() {
    rpc::Listener::new(&amp;platform::protocol::RpcProtocol, handler).leak();
}

fn handler(request: Vec&lt;u8&gt;) -&gt; Vec&lt;u8&gt; {
    // Parse and process the request.
    let result: Result&lt;String, String&gt; = try {
        let request = String::from_utf8(request).map_err(|_| "Request is not UTF-8")?;
        Command::parse(&amp;request)?.process()?
    };
    // Format output including error and next prompt.
    let mut output = result.unwrap_or_else(|error| format!("Error: {error}"));
    output.push_str("\n&gt; ");
    output.into_bytes()
}

enum Command&lt;'a&gt; {
    Help,
    Insert { key: Key, value: &amp;'a str },
    Find { key: Key },
    Remove { key: Key },
}

impl&lt;'a&gt; Command&lt;'a&gt; {
    fn parse(input: &amp;'a str) -&gt; Result&lt;Self, String&gt; {
        Ok(match *input.split_whitespace().collect::&lt;Vec&lt;_&gt;&gt;().as_slice() {
            [] | ["help"] =&gt; Command::Help,
            ["insert", key, value] =&gt; Command::Insert { key: Key::parse(key)?, value },
            ["find", key] =&gt; Command::Find { key: Key::parse(key)? },
            ["remove", key] =&gt; Command::Remove { key: Key::parse(key)? },
            [command, ..] =&gt; return Err(format!("Invalid command {command:?}")),
        })
    }

    fn process(&amp;self) -&gt; Result&lt;String, String&gt; {
        match self {
            Command::Help =&gt; Ok("\
Usage: insert &lt;key&gt;[..&lt;key&gt;] &lt;value&gt;
Usage: find &lt;key&gt;[..&lt;key&gt;]
Usage: remove &lt;key&gt;[..&lt;key&gt;]"
                .to_string()),
            Command::Insert { key, value } =&gt; match insert(key, value.as_bytes()) {
                Ok(()) =&gt; Ok("Done".to_string()),
                Err(error) =&gt; Err(format!("{error}")),
            },
            Command::Find { key } =&gt; match find(key) {
                Ok(None) =&gt; Ok("Not found".to_string()),
                Ok(Some(value)) =&gt; match core::str::from_utf8(&amp;value) {
                    Ok(value) =&gt; Ok(format!("Found: {value}")),
                    Err(_) =&gt; Ok(format!("Found (not UTF-8): {value:02x?}")),
                },
                Err(error) =&gt; Err(format!("{error}")),
            },
            Command::Remove { key } =&gt; match remove(key) {
                Ok(()) =&gt; Ok("Done".to_string()),
                Err(error) =&gt; Err(format!("{error}")),
            },
        }
    }
}

enum Key {
    Exact(usize),
    Range(Range&lt;usize&gt;),
}

impl FromStr for Key {
    type Err = ParseIntError;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        match s.split_once("..") {
            Some((start, end)) =&gt; Ok(Key::Range(start.parse()? .. end.parse()?)),
            None =&gt; Ok(Key::Exact(s.parse()?)),
        }
    }
}

impl Key {
    fn parse(key: &amp;str) -&gt; Result&lt;Self, String&gt; {
        let key: Key = key.parse().map_err(|_| "Failed to parse key")?;
        let valid = match &amp;key {
            Key::Exact(key) =&gt; *key &lt; 4096,
            Key::Range(keys) =&gt; !keys.is_empty() &amp;&amp; keys.end &lt; 4096,
        };
        if !valid {
            return Err("Invalid key".to_string());
        }
        Ok(key)
    }
}

fn insert(key: &amp;Key, value: &amp;[u8]) -&gt; Result&lt;(), Error&gt; {
    match key {
        Key::Exact(key) =&gt; store::insert(*key, value),
        Key::Range(keys) =&gt; store::fragment::insert(keys.clone(), value),
    }
}

fn find(key: &amp;Key) -&gt; Result&lt;Option&lt;Box&lt;[u8]&gt;&gt;, Error&gt; {
    match key {
        Key::Exact(key) =&gt; store::find(*key),
        Key::Range(keys) =&gt; store::fragment::find(keys.clone()),
    }
}

fn remove(key: &amp;Key) -&gt; Result&lt;(), Error&gt; {
    match key {
        Key::Exact(key) =&gt; store::remove(*key),
        Key::Range(keys) =&gt; store::fragment::remove(keys.clone()),
    }
}</code></pre></pre>
<h2 id="testing-5"><a class="header" href="#testing-5">Testing</a></h2>
<p>We can use a one-liner REPL in shell around <code>wasefire applet-rpc</code>:</p>
<pre><code class="language-shell">while read line; do echo "$line" | wasefire applet-rpc; done
</code></pre>
<p>An example interaction could look like this:</p>
<pre><code class="language-text">help
Usage: insert &lt;key&gt;[..&lt;key&gt;] &lt;value&gt;
Usage: find &lt;key&gt;[..&lt;key&gt;]
Usage: remove &lt;key&gt;[..&lt;key&gt;]
&gt; insert 0 hello world
Error: Invalid command "insert"
&gt; insert 0 hello-world
Done
&gt; find 0
Found: hello-world
&gt; find 1
Not found
&gt; remove 0
Done
&gt; find 0
Not found
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercises"><a class="header" href="#exercises">Exercises</a></h1>
<p>The
<a href="https://github.com/google/wasefire/tree/main/examples/rust/exercises"><code>examples/rust/exercises</code></a> of
the Wasefire repository contains exercises to implement an applet that behaves like a security key
over UART.</p>
<p>The <code>part-&lt;n&gt;</code> directories contain the successive parts towards the final applet. You will need to
modify those applets by fixing the different <code>TODO</code> comments. The exercise description is at the top
of the <code>src/lib.rs</code> file.</p>
<p>The <code>part-&lt;n&gt;-sol</code> directories contain the solution for each part. You don't need to modify those
applets. You can look at them for hints while working <code>part-&lt;n&gt;</code>.</p>
<p>The <code>client</code> directory contains a binary to communicate with the applet. You don't need to modify
this binary. You can build it with <code>cargo run --release</code> from the <code>client</code> directory, then execute
it from the host platform directory with <code>$WASEFIRE_REPO/target/release/client</code>. You can also copy
the executable to the host platform directory and use <code>./client</code>. You need to run it from the host
platform directory because it assumes the UART socket to be at <code>wasefire/host/uart0</code> (which is the
default for the host platform).</p>
<p>The <code>interface</code> directory contains a library defining the interface between the applet and the
client. You don't need to modify this library but you need to read its documentation. You will use
it from the applet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p>There are a few <a href="https://github.com/google/wasefire/tree/main/examples/rust">existing applets</a> that
demonstrate simple usage of the prelude. Each example starts with a short documentation in its
<code>src/lib.rs</code> file.</p>
<p>Noticeable examples are:</p>
<ul>
<li><code>hsm</code> implements some simple HSM-like API using the <code>crypto</code>, <code>store</code>, and <code>usb::serial</code> modules
of the prelude. It comes with a companion program to interact with the applet (see the
documentation in the <code>src/lib.rs</code> of the applet).</li>
<li><code>ctap</code> implements some simple CTAP-like API using the <code>button</code>, <code>led</code>, <code>timer</code>,<code>scheduling</code>,
<code>store</code>, and <code>usb::serial</code> modules of the prelude. It describes its usage when connecting to the
USB serial interface.</li>
<li><code>memory_game</code> implements some memory game using the <code>usb::serial</code> module of the prelude. It
describes its usage when connecting to the USB serial interface.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runner-user-guide"><a class="header" href="#runner-user-guide">Runner user guide</a></h1>
<p>This chapter will describe how you can add support for a board. It is not yet written though and
only provides a link to the API to implement.</p>
<p>There's currently only 2 supported boards:</p>
<ul>
<li><code>nordic</code> for nRF52840-dk</li>
<li><code>host</code> for Linux (not clear if more or less is actually supported)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-1"><a class="header" href="#api-1">API</a></h1>
<p>The board API is documented <a href="https://docs.rs/wasefire-board-api">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frequently-asked-questions"><a class="header" href="#frequently-asked-questions">Frequently asked questions</a></h1>
<p>This section tries to answer common questions. If your question is not listed
here, please open an <a href="https://github.com/google/wasefire/issues/new">issue</a>.</p>
<h3 id="are-applets-trusted-to-be-correct"><a class="header" href="#are-applets-trusted-to-be-correct">Are applets trusted to be correct?</a></h3>
<p>No. The platform does not trust applets and applets do not trust each other.
However, if an applet has a valid signature, then the platform trusts the
permissions required by the applet.</p>
<h3 id="are-applets-executed-as-native-code"><a class="header" href="#are-applets-executed-as-native-code">Are applets executed as native code?</a></h3>
<p>No. Applets are installed as WebAssembly byte-code. This is required since the
static guarantees provided by WebAssembly apply to the byte-code and the
platform checks those guarantees. For execution, applets are interpreted: either
directly from the byte-code, or for performance purposes from an optimized
representation in flash or RAM which may be computed ahead-of-time or on-demand.</p>
<h3 id="why-is-performance-not-an-issue"><a class="header" href="#why-is-performance-not-an-issue">Why is performance not an issue?</a></h3>
<p>The main bets are:</p>
<ul>
<li>Computing intensive code (like cryptography) is done in hardware or native
code (in the platform).</li>
<li>Applets are supposed to only do business logic which is assumed to not be
computing intensive.</li>
<li>The platform targets users who can't write embedded code, so the main concern
is not performance but making firmware development accessible.</li>
</ul>
<h3 id="how-does-this-fit-on-micro-controllers"><a class="header" href="#how-does-this-fit-on-micro-controllers">How does this fit on micro-controllers?</a></h3>
<p>The interpreter currently fits in 22kB when optimized for size and 66kB when
optimized for speed. The interpreter is also designed to have minimal RAM
overhead. However, most optimizations (for both performance and overhead) are
not yet implemented, which may increase the binary size.</p>
<h3 id="why-implement-a-new-interpreter"><a class="header" href="#why-implement-a-new-interpreter">Why implement a new interpreter?</a></h3>
<p>The following runtimes have been quickly rejected:</p>
<ul>
<li><code>wasmtime</code> and <code>wasmer</code> don't support no-std</li>
<li><code>wasmi</code> consumes too much RAM for embedded</li>
</ul>
<p><code>wasm3</code> has been used during the initial phase of the project but got eventually
replaced with a custom interpreter for the following reasons:</p>
<ul>
<li>It doesn't perform validation
<a href="https://github.com/wasm3/wasm3/issues/344">yet</a>. We probably need proper
validation.</li>
<li>It only compiles to RAM (not flash). We want to be able to preprocess a module
and persist the pre-computation in flash such that it is only done when a
module is installed and not each time it is instantiated.</li>
<li>It takes control of the execution flow. All runtimes I'm aware of behave like
that. To simplify scheduling, we want the interpreter to give back control
when asked or when a host function is called.</li>
<li>It is written in C. Although the code has tests and fuzzing, we want
additional security provided by the language.</li>
</ul>
<p>The interpreter we implemented is written in Rust, doesn't take control of the
execution thread, doesn't pre-compute anything yet (but will be able to
pre-compute to flash), and performs validation.</p>
<h3 id="applet-footprint-compared-to-native-code"><a class="header" href="#applet-footprint-compared-to-native-code">Applet footprint compared to native code?</a></h3>
<p>WebAssembly byte-code is compact so there should be a footprint benefit compared
to native code. However, no benchmarks have been done in that regard.</p>
<h3 id="is-it-possible-to-share-code-between-applets"><a class="header" href="#is-it-possible-to-share-code-between-applets">Is it possible to share code between applets?</a></h3>
<p>Yes (although not yet implemented). Applets are represented at runtime by a
WebAssembly store which is unique per applet. Applets behavior is defined by a
set of WebAssembly modules which are instantiated to the applet store. Applets
may share those modules. A typical example would be an allocator module.
Multiple applets may use the same allocator byte-code (from the module) to
manage their own linear memory (from the module instance in the applet store).</p>
<h3 id="what-third-party-dependencies-are-used"><a class="header" href="#what-third-party-dependencies-are-used">What third-party dependencies are used?</a></h3>
<p>The minimum set of third-party dependencies is currently:</p>
<ul>
<li><code>num_enum</code> for the interpreter</li>
<li><code>usb-device</code> and <code>usbd-serial</code> for the board API</li>
</ul>
<p>Additional dependencies are used by:</p>
<ul>
<li>the actual board implementation:
<ul>
<li>(e.g. <code>cortex-m-rt</code>, <code>nrf52840-hal</code>, <code>panic-abort</code> for nordic)</li>
<li>(e.g. <code>tokio</code>, <code>usbip-device</code>, <code>aes</code>, <code>rand</code> for linux)</li>
</ul>
</li>
<li>compilation (e.g. <code>proc-macro2</code>, <code>quote</code>)</li>
<li>debugging (e.g. <code>defmt</code>, <code>defmt-rtt</code>, <code>log</code>, <code>env_logger</code>)</li>
<li>tooling (e.g. <code>anyhow</code>, <code>clap</code>)</li>
</ul>
<p>In particular, the project doesn't need any operating system (e.g. TockOS) but
may use one as part of a board implementation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="links"><a class="header" href="#links">Links</a></h1>
<h2 id="project"><a class="header" href="#project">Project</a></h2>
<ul>
<li>Website: <a href="https://google.github.io/wasefire">https://google.github.io/wasefire</a></li>
<li>Github: <a href="https://github.com/google/wasefire">https://github.com/google/wasefire</a></li>
<li>Mailing list: <a href="https://groups.google.com/g/wasefire">https://groups.google.com/g/wasefire</a></li>
</ul>
<h2 id="presentations"><a class="header" href="#presentations">Presentations</a></h2>
<ul>
<li>Hardwear.io NL 2023 workshop
<a href="https://github.com/google/wasefire/blob/main/docs/presentations/2023-Hardwear.io-NL-workshop.pdf">slides</a></li>
</ul>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<ul>
<li>The <a href="https://google.github.io/wasefire/faq.html">FAQ</a> of this document</li>
<li>Rust prelude: <a href="https://docs.rs/wasefire">https://docs.rs/wasefire</a></li>
<li>Board API: <a href="https://docs.rs/wasefire-board-api">https://docs.rs/wasefire-board-api</a></li>
<li>Applet API: <a href="https://docs.rs/wasefire-applet-api">https://docs.rs/wasefire-applet-api</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="acknowledgments"><a class="header" href="#acknowledgments">Acknowledgments</a></h1>
<p>This project would not be where it is now if it couldn't build upon the
following projects<sup class="footnote-reference"><a href="#exhaustiveness">1</a></sup>:</p>
<div class="table-wrapper"><table><thead><tr><th>Project</th><th>Author</th><th>Usage</th></tr></thead><tbody>
<tr><td><a href="https://github.com/knurling-rs/defmt">defmt</a></td><td><a href="https://github.com/knurling-rs">Knurling</a></td><td>Logging for embedded</td></tr>
<tr><td><a href="https://github.com/knurling-rs/probe-run">probe-run</a></td><td><a href="https://github.com/knurling-rs">Knurling</a></td><td>(now replaced by probe-rs)</td></tr>
<tr><td><a href="https://github.com/probe-rs/probe-rs">probe-rs</a></td><td><a href="https://github.com/probe-rs">probe.rs</a></td><td>Flashing and debugging</td></tr>
<tr><td><a href="https://github.com/rust-embedded/cortex-m">cortex-m</a></td><td><a href="https://github.com/rust-embedded">Rust Embedded</a></td><td>Cortex-M support</td></tr>
<tr><td><a href="https://github.com/rust-embedded/riscv">riscv</a></td><td><a href="https://github.com/rust-embedded">Rust Embedded</a></td><td>RISC-V support</td></tr>
<tr><td><a href="https://github.com/rust-embedded/critical-section">critical-section</a></td><td><a href="https://github.com/rust-embedded">Rust Embedded</a></td><td>Mutex support</td></tr>
<tr><td><a href="https://github.com/taiki-e/portable-atomic">portable-atomic</a></td><td><a href="https://github.com/taiki-e">taiki-e</a></td><td>Atomic support</td></tr>
<tr><td><a href="https://github.com/rust-embedded-community/usb-device">usb-device</a></td><td><a href="https://github.com/rust-embedded-community">Rust Embedded Community</a></td><td>Generic USB interface</td></tr>
<tr><td><a href="https://github.com/rust-embedded-community/usbd-serial">usbd-serial</a></td><td><a href="https://github.com/rust-embedded-community">Rust Embedded Community</a></td><td>USB serial implementation</td></tr>
<tr><td><a href="https://github.com/Sawchord/usbip-device">usbip-device</a></td><td><a href="https://github.com/Sawchord">Sawchord</a></td><td>USB/IP implementation</td></tr>
<tr><td><a href="https://github.com/nrf-rs/nrf-hal">nrf-hal</a></td><td><a href="https://github.com/nrf-rs">nRF Rust</a></td><td>nRF52840 support</td></tr>
<tr><td><a href="https://github.com/nrf-rs/nrf-usbd">nrf-usbd</a></td><td><a href="https://github.com/nrf-rs">nRF Rust</a></td><td>nRF52840 USB implementation</td></tr>
<tr><td><a href="https://github.com/RustCrypto/hashes">hashes</a></td><td><a href="https://github.com/RustCrypto">Rust Crypto</a></td><td>SHA-256 and 384</td></tr>
<tr><td><a href="https://github.com/RustCrypto/MACs">MACs</a></td><td><a href="https://github.com/RustCrypto">Rust Crypto</a></td><td>HMAC-SHA-256 and 384</td></tr>
<tr><td><a href="https://github.com/RustCrypto/AEADs">AEADs</a></td><td><a href="https://github.com/RustCrypto">Rust Crypto</a></td><td>AES-128-CCM and 256-GCM</td></tr>
<tr><td><a href="https://github.com/RustCrypto/elliptic-curves">elliptic-curves</a></td><td><a href="https://github.com/RustCrypto">Rust Crypto</a></td><td>NIST P-256 and 384</td></tr>
<tr><td><a href="https://github.com/rust-lang/rust-analyzer">rust-analyzer</a></td><td><a href="https://github.com/rust-lang">Rust</a></td><td>Rust development</td></tr>
<tr><td><a href="https://github.com/wasm3/wasm3">wasm3</a></td><td><a href="https://github.com/wasm3">Wasm3 Labs</a></td><td>(not used anymore)</td></tr>
</tbody></table>
</div>
<p>We would like to thank all authors and contributors of those projects (as well
as those we use but we forgot to mention) and more generally the community
around Rust for embedded development. We are also grateful to those who answered
our issues [<a href="https://github.com/probe-rs/probe-rs/issues/1865">1</a>, <a href="https://github.com/rust-embedded/critical-section/issues/42">2</a>, <a href="https://github.com/probe-rs/probe-rs/issues/1863">3</a>, <a href="https://github.com/probe-rs/probe-rs/issues/1816">4</a>, <a href="https://github.com/knurling-rs/probe-run/issues/421">5</a>, <a href="https://github.com/RustCrypto/traits/issues/1311">6</a>, <a href="https://github.com/RustCrypto/KDFs/issues/80">7</a>, <a href="https://github.com/RustCrypto/traits/issues/1307">8</a>, <a href="https://github.com/knurling-rs/defmt/issues/738">9</a>] and reviewed our pull
requests [<a href="https://github.com/probe-rs/probe-rs/pull/1919">10</a>, <a href="https://github.com/nrf-rs/nrf-usbd/pull/17">11</a>, <a href="https://github.com/Sawchord/usbip-device/pull/5">12</a>, <a href="https://github.com/rust-embedded-community/usb-device/pull/115">13</a>].</p>
<div class="footnote-definition" id="exhaustiveness"><sup class="footnote-definition-label">1</sup>
<p>We tried to focus on the projects that were critical to get
where we are now. Some projects are thus deliberately left out (and some
projects that we don't use anymore are still listed). But it is also
possible that we forgot to list some, in which case we apologize and would
be happy to fix our oversight if notified.</p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
