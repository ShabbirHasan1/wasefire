<!DOCTYPE HTML>
<html lang="en" class="rust" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Storage - Wasefire</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('rust')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../index.html">Introduction</a></li><li class="chapter-item expanded "><a href="../../overview/index.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../overview/terminology.html"><strong aria-hidden="true">1.1.</strong> Terminology</a></li><li class="chapter-item expanded "><a href="../../overview/features.html"><strong aria-hidden="true">1.2.</strong> Features</a></li></ol></li><li class="chapter-item expanded "><a href="../../quick/index.html"><strong aria-hidden="true">2.</strong> Quick start</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../quick/codespace.html"><strong aria-hidden="true">2.1.</strong> GitHub Codespace tips</a></li></ol></li><li class="chapter-item expanded "><a href="../../applet/index.html"><strong aria-hidden="true">3.</strong> Applet user guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../applet/create.html"><strong aria-hidden="true">3.1.</strong> Create a new applet</a></li><li class="chapter-item expanded "><a href="../../applet/run.html"><strong aria-hidden="true">3.2.</strong> Run an applet</a></li><li class="chapter-item expanded "><a href="../../applet/api.html"><strong aria-hidden="true">3.3.</strong> API</a></li><li class="chapter-item expanded "><a href="../../applet/prelude/index.html"><strong aria-hidden="true">3.4.</strong> Prelude</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../applet/prelude/led.html"><strong aria-hidden="true">3.4.1.</strong> LEDs</a></li><li class="chapter-item expanded "><a href="../../applet/prelude/button.html"><strong aria-hidden="true">3.4.2.</strong> Buttons</a></li><li class="chapter-item expanded "><a href="../../applet/prelude/timer.html"><strong aria-hidden="true">3.4.3.</strong> Timers</a></li><li class="chapter-item expanded "><a href="../../applet/prelude/usb.html"><strong aria-hidden="true">3.4.4.</strong> USB</a></li><li class="chapter-item expanded "><a href="../../applet/prelude/uart.html"><strong aria-hidden="true">3.4.5.</strong> UART</a></li><li class="chapter-item expanded "><a href="../../applet/prelude/rpc.html"><strong aria-hidden="true">3.4.6.</strong> RPC</a></li><li class="chapter-item expanded "><a href="../../applet/prelude/store.html" class="active"><strong aria-hidden="true">3.4.7.</strong> Storage</a></li></ol></li><li class="chapter-item expanded "><a href="../../applet/exercises/index.html"><strong aria-hidden="true">3.5.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="../../applet/examples.html"><strong aria-hidden="true">3.6.</strong> Examples</a></li></ol></li><li class="chapter-item expanded "><a href="../../runner/index.html"><strong aria-hidden="true">4.</strong> Runner user guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../runner/api.html"><strong aria-hidden="true">4.1.</strong> API</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Developer guide</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Design</div></li></ol></li><li class="chapter-item expanded "><a href="../../faq.html">FAQ</a></li><li class="chapter-item expanded affix "><a href="../../links.html">Links</a></li><li class="chapter-item expanded affix "><a href="../../acknowledgments.html">Acknowledgments</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Wasefire</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/google/wasefire/tree/main/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="storage"><a class="header" href="#storage">Storage</a></h1>
<p>For now only a key-value store is supported for persistent storage. Eventually, additional
facilities may be added: a cyclic logging journal, a file-system, raw flash access, etc.</p>
<p>In this section, we will illustrate the key-value store usage by walking through the <code>store</code> example
which provides direct store access with a text-based interface through the platform protocol applet
RPC mechanism.</p>
<p>The key-value store has 2 restrictions:</p>
<ul>
<li>Keys must be between 0 and 4095</li>
<li>Values must be at most 1023 bytes</li>
</ul>
<p>The second restriction can be worked around by storing large entries as multiple fragments of at
most 1023 bytes each using multiple keys. To support those large entries, we define an abstract
notion of keys. An abstract key is either exactly one key, or a contiguous range of keys.</p>
<pre><code class="language-rust no_run noplayground">enum Key {
    Exact(usize),
    Range(Range&lt;usize&gt;),
}</code></pre>
<p>The store provides 3 operations: <code>insert</code>, <code>find</code>, and <code>remove</code>. Each of those operation comes with
a fragmented variant (working on a range of keys for large values). We define helpers to dispatch to
the regular or fragmented version based on the abstract key.</p>
<pre><code class="language-rust no_run noplayground">fn insert(key: &amp;Key, value: &amp;[u8]) -&gt; Result&lt;(), Error&gt; {
    match key {
        Key::Exact(key) =&gt; store::insert(*key, value),
        Key::Range(keys) =&gt; store::fragment::insert(keys.clone(), value),
    }
}

fn find(key: &amp;Key) -&gt; Result&lt;Option&lt;Box&lt;[u8]&gt;&gt;, Error&gt; {
    match key {
        Key::Exact(key) =&gt; store::find(*key),
        Key::Range(keys) =&gt; store::fragment::find(keys.clone()),
    }
}

fn remove(key: &amp;Key) -&gt; Result&lt;(), Error&gt; {
    match key {
        Key::Exact(key) =&gt; store::remove(*key),
        Key::Range(keys) =&gt; store::fragment::remove(keys.clone()),
    }
}</code></pre>
<p>To ease parsing and processing of RPC requests, we define a straightforward type for commands.</p>
<pre><code class="language-rust no_run noplayground">enum Command&lt;'a&gt; {
    Help,
    Insert { key: Key, value: &amp;'a str },
    Find { key: Key },
    Remove { key: Key },
}</code></pre>
<p>The parsing function is also straightforward.</p>
<pre><code class="language-rust no_run noplayground">impl&lt;'a&gt; Command&lt;'a&gt; {
    fn parse(input: &amp;'a str) -&gt; Result&lt;Self, String&gt; {
        Ok(match *input.split_whitespace().collect::&lt;Vec&lt;_&gt;&gt;().as_slice() {
            [] | ["help"] =&gt; Command::Help,
            ["insert", key, value] =&gt; Command::Insert { key: Key::parse(key)?, value },
            ["find", key] =&gt; Command::Find { key: Key::parse(key)? },
            ["remove", key] =&gt; Command::Remove { key: Key::parse(key)? },
            [command, ..] =&gt; return Err(format!("Invalid command {command:?}")),
        })
    }</code></pre>
<p>The process function is more interesting as we'll describe how the store operations behave. When
processing a command, we may either succeed with an output, or fail with an error. We use strings
because we implement a text-based interface.</p>
<pre><code class="language-rust no_run noplayground">    fn process(&amp;self) -&gt; Result&lt;String, String&gt; {</code></pre>
<p>For the help command, we simply output the grammar for commands.</p>
<pre><code class="language-rust no_run noplayground">        match self {
            Command::Help =&gt; Ok("\
Usage: insert &lt;key&gt;[..&lt;key&gt;] &lt;value&gt;
Usage: find &lt;key&gt;[..&lt;key&gt;]
Usage: remove &lt;key&gt;[..&lt;key&gt;]"
                .to_string()),</code></pre>
<p>For insert commands, we use our helper function for abstract keys and format the output and error
appropriately. When inserting to the store, if the key (or range of keys) is already present, then
its value is overwritten.</p>
<pre><code class="language-rust no_run noplayground">            Command::Insert { key, value } =&gt; match insert(key, value.as_bytes()) {
                Ok(()) =&gt; Ok("Done".to_string()),
                Err(error) =&gt; Err(format!("{error}")),
            },</code></pre>
<p>Remove commands are similar. When removing from the store, it is not an error if the key (or range
of keys) is absent.</p>
<pre><code class="language-rust no_run noplayground">            Command::Remove { key } =&gt; match remove(key) {
                Ok(()) =&gt; Ok("Done".to_string()),
                Err(error) =&gt; Err(format!("{error}")),
            },</code></pre>
<p>Find commands also use the helper function, however they have 2 possible outputs (outside errors):</p>
<ul>
<li>If the key is absent from the store, then <code>None</code> is returned.</li>
<li>If the key is present, then <code>Some</code> is returned with the bytes of the value. Because we implement a
text-based interface, we try to convert the byte slice to a string slice for the output.</li>
</ul>
<pre><code class="language-rust no_run noplayground">            Command::Find { key } =&gt; match find(key) {
                Ok(None) =&gt; Ok("Not found".to_string()),
                Ok(Some(value)) =&gt; match core::str::from_utf8(&amp;value) {
                    Ok(value) =&gt; Ok(format!("Found: {value}")),
                    Err(_) =&gt; Ok(format!("Found (not UTF-8): {value:02x?}")),
                },
                Err(error) =&gt; Err(format!("{error}")),
            },</code></pre>
<p>We can finally write our handler function taking a request as argument and returning a response.</p>
<pre><code class="language-rust no_run noplayground">fn handler(request: Vec&lt;u8&gt;) -&gt; Vec&lt;u8&gt; {
    // Parse and process the request.
    let result: Result&lt;String, String&gt; = try {
        let request = String::from_utf8(request).map_err(|_| "Request is not UTF-8")?;
        Command::parse(&amp;request)?.process()?
    };
    // Format output including error and next prompt.
    let mut output = result.unwrap_or_else(|error| format!("Error: {error}"));
    output.push_str("\n&gt; ");
    output.into_bytes()
}</code></pre>
<p>The main function simply registers an RPC listener with the handler above.</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    rpc::Listener::new(&amp;platform::protocol::RpcProtocol, handler).leak();
}</code></pre>
<p>The final code looks like this:</p>
<pre><pre class="playground"><code class="language-rust no_run">#![no_std]
#![feature(try_blocks)]
wasefire::applet!();

use alloc::boxed::Box;
use alloc::format;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::num::ParseIntError;
use core::ops::Range;
use core::str::FromStr;

fn main() {
    rpc::Listener::new(&amp;platform::protocol::RpcProtocol, handler).leak();
}

fn handler(request: Vec&lt;u8&gt;) -&gt; Vec&lt;u8&gt; {
    // Parse and process the request.
    let result: Result&lt;String, String&gt; = try {
        let request = String::from_utf8(request).map_err(|_| "Request is not UTF-8")?;
        Command::parse(&amp;request)?.process()?
    };
    // Format output including error and next prompt.
    let mut output = result.unwrap_or_else(|error| format!("Error: {error}"));
    output.push_str("\n&gt; ");
    output.into_bytes()
}

enum Command&lt;'a&gt; {
    Help,
    Insert { key: Key, value: &amp;'a str },
    Find { key: Key },
    Remove { key: Key },
}

impl&lt;'a&gt; Command&lt;'a&gt; {
    fn parse(input: &amp;'a str) -&gt; Result&lt;Self, String&gt; {
        Ok(match *input.split_whitespace().collect::&lt;Vec&lt;_&gt;&gt;().as_slice() {
            [] | ["help"] =&gt; Command::Help,
            ["insert", key, value] =&gt; Command::Insert { key: Key::parse(key)?, value },
            ["find", key] =&gt; Command::Find { key: Key::parse(key)? },
            ["remove", key] =&gt; Command::Remove { key: Key::parse(key)? },
            [command, ..] =&gt; return Err(format!("Invalid command {command:?}")),
        })
    }

    fn process(&amp;self) -&gt; Result&lt;String, String&gt; {
        match self {
            Command::Help =&gt; Ok("\
Usage: insert &lt;key&gt;[..&lt;key&gt;] &lt;value&gt;
Usage: find &lt;key&gt;[..&lt;key&gt;]
Usage: remove &lt;key&gt;[..&lt;key&gt;]"
                .to_string()),
            Command::Insert { key, value } =&gt; match insert(key, value.as_bytes()) {
                Ok(()) =&gt; Ok("Done".to_string()),
                Err(error) =&gt; Err(format!("{error}")),
            },
            Command::Find { key } =&gt; match find(key) {
                Ok(None) =&gt; Ok("Not found".to_string()),
                Ok(Some(value)) =&gt; match core::str::from_utf8(&amp;value) {
                    Ok(value) =&gt; Ok(format!("Found: {value}")),
                    Err(_) =&gt; Ok(format!("Found (not UTF-8): {value:02x?}")),
                },
                Err(error) =&gt; Err(format!("{error}")),
            },
            Command::Remove { key } =&gt; match remove(key) {
                Ok(()) =&gt; Ok("Done".to_string()),
                Err(error) =&gt; Err(format!("{error}")),
            },
        }
    }
}

enum Key {
    Exact(usize),
    Range(Range&lt;usize&gt;),
}

impl FromStr for Key {
    type Err = ParseIntError;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        match s.split_once("..") {
            Some((start, end)) =&gt; Ok(Key::Range(start.parse()? .. end.parse()?)),
            None =&gt; Ok(Key::Exact(s.parse()?)),
        }
    }
}

impl Key {
    fn parse(key: &amp;str) -&gt; Result&lt;Self, String&gt; {
        let key: Key = key.parse().map_err(|_| "Failed to parse key")?;
        let valid = match &amp;key {
            Key::Exact(key) =&gt; *key &lt; 4096,
            Key::Range(keys) =&gt; !keys.is_empty() &amp;&amp; keys.end &lt; 4096,
        };
        if !valid {
            return Err("Invalid key".to_string());
        }
        Ok(key)
    }
}

fn insert(key: &amp;Key, value: &amp;[u8]) -&gt; Result&lt;(), Error&gt; {
    match key {
        Key::Exact(key) =&gt; store::insert(*key, value),
        Key::Range(keys) =&gt; store::fragment::insert(keys.clone(), value),
    }
}

fn find(key: &amp;Key) -&gt; Result&lt;Option&lt;Box&lt;[u8]&gt;&gt;, Error&gt; {
    match key {
        Key::Exact(key) =&gt; store::find(*key),
        Key::Range(keys) =&gt; store::fragment::find(keys.clone()),
    }
}

fn remove(key: &amp;Key) -&gt; Result&lt;(), Error&gt; {
    match key {
        Key::Exact(key) =&gt; store::remove(*key),
        Key::Range(keys) =&gt; store::fragment::remove(keys.clone()),
    }
}</code></pre></pre>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>We can use a one-liner REPL in shell around <code>wasefire applet-rpc</code>:</p>
<pre><code class="language-shell">while read line; do echo "$line" | wasefire applet-rpc; done
</code></pre>
<p>An example interaction could look like this:</p>
<pre><code class="language-text">help
Usage: insert &lt;key&gt;[..&lt;key&gt;] &lt;value&gt;
Usage: find &lt;key&gt;[..&lt;key&gt;]
Usage: remove &lt;key&gt;[..&lt;key&gt;]
&gt; insert 0 hello world
Error: Invalid command "insert"
&gt; insert 0 hello-world
Done
&gt; find 0
Found: hello-world
&gt; find 1
Not found
&gt; remove 0
Done
&gt; find 0
Not found
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../applet/prelude/rpc.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../applet/exercises/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../applet/prelude/rpc.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../applet/exercises/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
